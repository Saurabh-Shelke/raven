var Si = Object.defineProperty;
var Ti = (t, e, n) => e in t ? Si(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var Ie = (t, e, n) => (Ti(t, typeof e != "symbol" ? e + "" : e, n), n);
import Xe, { createContext as ls, useEffect as at, useLayoutEffect as Oi, useContext as Y, useMemo as Kt, useRef as Ae, createElement as xi, useCallback as P, useDebugValue as Ci, useState as I } from "react";
var F = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, vn = {}, pt = {}, St = {}, ye = F && F.__assign || function() {
  return ye = Object.assign || function(t) {
    for (var e, n = 1, r = arguments.length; n < r; n++) {
      e = arguments[n];
      for (var s in e)
        Object.prototype.hasOwnProperty.call(e, s) && (t[s] = e[s]);
    }
    return t;
  }, ye.apply(this, arguments);
}, Pt = F && F.__awaiter || function(t, e, n, r) {
  function s(i) {
    return i instanceof n ? i : new n(function(o) {
      o(i);
    });
  }
  return new (n || (n = Promise))(function(i, o) {
    function c(f) {
      try {
        a(r.next(f));
      } catch (h) {
        o(h);
      }
    }
    function l(f) {
      try {
        a(r.throw(f));
      } catch (h) {
        o(h);
      }
    }
    function a(f) {
      f.done ? i(f.value) : s(f.value).then(c, l);
    }
    a((r = r.apply(t, e || [])).next());
  });
}, kt = F && F.__generator || function(t, e) {
  var n = { label: 0, sent: function() {
    if (i[0] & 1)
      throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, s, i, o;
  return o = { next: c(0), throw: c(1), return: c(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function c(a) {
    return function(f) {
      return l([a, f]);
    };
  }
  function l(a) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, a[0] && (n = 0)), n; )
      try {
        if (r = 1, s && (i = a[0] & 2 ? s.return : a[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, a[1])).done)
          return i;
        switch (s = 0, i && (a = [a[0] & 2, i.value]), a[0]) {
          case 0:
          case 1:
            i = a;
            break;
          case 4:
            return n.label++, { value: a[1], done: !1 };
          case 5:
            n.label++, s = a[1], a = [0];
            continue;
          case 7:
            a = n.ops.pop(), n.trys.pop();
            continue;
          default:
            if (i = n.trys, !(i = i.length > 0 && i[i.length - 1]) && (a[0] === 6 || a[0] === 2)) {
              n = 0;
              continue;
            }
            if (a[0] === 3 && (!i || a[1] > i[0] && a[1] < i[3])) {
              n.label = a[1];
              break;
            }
            if (a[0] === 6 && n.label < i[1]) {
              n.label = i[1], i = a;
              break;
            }
            if (i && n.label < i[2]) {
              n.label = i[2], n.ops.push(a);
              break;
            }
            i[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        a = e.call(t, n);
      } catch (f) {
        a = [6, f], s = 0;
      } finally {
        r = i = 0;
      }
    if (a[0] & 5)
      throw a[1];
    return { value: a[0] ? a[1] : void 0, done: !0 };
  }
};
Object.defineProperty(St, "__esModule", { value: !0 });
St.FrappeCall = void 0;
var Ai = function() {
  function t(e, n, r, s, i) {
    this.appURL = e, this.axios = n, this.useToken = r != null ? r : !1, this.token = s, this.tokenType = i;
  }
  return t.prototype.get = function(e, n) {
    return Pt(this, void 0, void 0, function() {
      var r;
      return kt(this, function(s) {
        return r = new URLSearchParams(), n && Object.entries(n).forEach(function(i) {
          var o = i[0], c = i[1];
          if (c != null) {
            var l = typeof c == "object" ? JSON.stringify(c) : c;
            r.set(o, l);
          }
        }), [2, this.axios.get("/api/method/".concat(e), {
          params: r
        }).then(function(i) {
          return i.data;
        }).catch(function(i) {
          var o, c;
          throw ye(ye({}, i.response.data), { httpStatus: i.response.status, httpStatusText: i.response.statusText, message: (o = i.response.data.message) !== null && o !== void 0 ? o : "There was an error.", exception: (c = i.response.data.exception) !== null && c !== void 0 ? c : "" });
        })];
      });
    });
  }, t.prototype.post = function(e, n) {
    return Pt(this, void 0, void 0, function() {
      return kt(this, function(r) {
        return [2, this.axios.post("/api/method/".concat(e), ye({}, n)).then(function(s) {
          return s.data;
        }).catch(function(s) {
          var i, o;
          throw ye(ye({}, s.response.data), { httpStatus: s.response.status, httpStatusText: s.response.statusText, message: (i = s.response.data.message) !== null && i !== void 0 ? i : "There was an error.", exception: (o = s.response.data.exception) !== null && o !== void 0 ? o : "" });
        })];
      });
    });
  }, t.prototype.put = function(e, n) {
    return Pt(this, void 0, void 0, function() {
      return kt(this, function(r) {
        return [2, this.axios.put("/api/method/".concat(e), ye({}, n)).then(function(s) {
          return s.data;
        }).catch(function(s) {
          var i, o;
          throw ye(ye({}, s.response.data), { httpStatus: s.response.status, httpStatusText: s.response.statusText, message: (i = s.response.data.message) !== null && i !== void 0 ? i : "There was an error.", exception: (o = s.response.data.exception) !== null && o !== void 0 ? o : "" });
        })];
      });
    });
  }, t.prototype.delete = function(e, n) {
    return Pt(this, void 0, void 0, function() {
      return kt(this, function(r) {
        return [2, this.axios.delete("/api/method/".concat(e), { params: n }).then(function(s) {
          return s.data;
        }).catch(function(s) {
          var i, o;
          throw ye(ye({}, s.response.data), { httpStatus: s.response.status, httpStatusText: s.response.statusText, message: (i = s.response.data.message) !== null && i !== void 0 ? i : "There was an error.", exception: (o = s.response.data.exception) !== null && o !== void 0 ? o : "" });
        })];
      });
    });
  }, t;
}();
St.FrappeCall = Ai;
var Tt = {}, Z = F && F.__assign || function() {
  return Z = Object.assign || function(t) {
    for (var e, n = 1, r = arguments.length; n < r; n++) {
      e = arguments[n];
      for (var s in e)
        Object.prototype.hasOwnProperty.call(e, s) && (t[s] = e[s]);
    }
    return t;
  }, Z.apply(this, arguments);
}, ze = F && F.__awaiter || function(t, e, n, r) {
  function s(i) {
    return i instanceof n ? i : new n(function(o) {
      o(i);
    });
  }
  return new (n || (n = Promise))(function(i, o) {
    function c(f) {
      try {
        a(r.next(f));
      } catch (h) {
        o(h);
      }
    }
    function l(f) {
      try {
        a(r.throw(f));
      } catch (h) {
        o(h);
      }
    }
    function a(f) {
      f.done ? i(f.value) : s(f.value).then(c, l);
    }
    a((r = r.apply(t, e || [])).next());
  });
}, Je = F && F.__generator || function(t, e) {
  var n = { label: 0, sent: function() {
    if (i[0] & 1)
      throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, s, i, o;
  return o = { next: c(0), throw: c(1), return: c(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function c(a) {
    return function(f) {
      return l([a, f]);
    };
  }
  function l(a) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, a[0] && (n = 0)), n; )
      try {
        if (r = 1, s && (i = a[0] & 2 ? s.return : a[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, a[1])).done)
          return i;
        switch (s = 0, i && (a = [a[0] & 2, i.value]), a[0]) {
          case 0:
          case 1:
            i = a;
            break;
          case 4:
            return n.label++, { value: a[1], done: !1 };
          case 5:
            n.label++, s = a[1], a = [0];
            continue;
          case 7:
            a = n.ops.pop(), n.trys.pop();
            continue;
          default:
            if (i = n.trys, !(i = i.length > 0 && i[i.length - 1]) && (a[0] === 6 || a[0] === 2)) {
              n = 0;
              continue;
            }
            if (a[0] === 3 && (!i || a[1] > i[0] && a[1] < i[3])) {
              n.label = a[1];
              break;
            }
            if (a[0] === 6 && n.label < i[1]) {
              n.label = i[1], i = a;
              break;
            }
            if (i && n.label < i[2]) {
              n.label = i[2], n.ops.push(a);
              break;
            }
            i[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        a = e.call(t, n);
      } catch (f) {
        a = [6, f], s = 0;
      } finally {
        r = i = 0;
      }
    if (a[0] & 5)
      throw a[1];
    return { value: a[0] ? a[1] : void 0, done: !0 };
  }
};
Object.defineProperty(Tt, "__esModule", { value: !0 });
Tt.FrappeDB = void 0;
var Di = function() {
  function t(e, n, r, s, i) {
    this.appURL = e, this.axios = n, this.useToken = r != null ? r : !1, this.token = s, this.tokenType = i;
  }
  return t.prototype.getDoc = function(e, n) {
    return n === void 0 && (n = ""), ze(this, void 0, void 0, function() {
      return Je(this, function(r) {
        return [2, this.axios.get("/api/resource/".concat(e, "/").concat(encodeURIComponent(n))).then(function(s) {
          return s.data.data;
        }).catch(function(s) {
          var i, o;
          throw Z(Z({}, s.response.data), { httpStatus: s.response.status, httpStatusText: s.response.statusText, message: "There was an error while fetching the document.", exception: (o = (i = s.response.data.exception) !== null && i !== void 0 ? i : s.response.data.exc_type) !== null && o !== void 0 ? o : "" });
        })];
      });
    });
  }, t.prototype.getDocList = function(e, n) {
    var r;
    return ze(this, void 0, void 0, function() {
      var s, i, o, c, l, a, f, h, y, m, p;
      return Je(this, function(g) {
        return s = {}, n && (i = n.fields, o = n.filters, c = n.orFilters, l = n.orderBy, a = n.limit, f = n.limit_start, h = n.groupBy, y = n.asDict, m = y === void 0 ? !0 : y, p = l ? "".concat(String(l == null ? void 0 : l.field), " ").concat((r = l == null ? void 0 : l.order) !== null && r !== void 0 ? r : "asc") : "", s = {
          fields: i ? JSON.stringify(i) : void 0,
          filters: o ? JSON.stringify(o) : void 0,
          or_filters: c ? JSON.stringify(c) : void 0,
          order_by: p,
          group_by: h,
          limit: a,
          limit_start: f,
          as_dict: m
        }), [2, this.axios.get("/api/resource/".concat(e), { params: s }).then(function(w) {
          return w.data.data;
        }).catch(function(w) {
          var b, E;
          throw Z(Z({}, w.response.data), { httpStatus: w.response.status, httpStatusText: w.response.statusText, message: "There was an error while fetching the documents.", exception: (E = (b = w.response.data.exception) !== null && b !== void 0 ? b : w.response.data.exc_type) !== null && E !== void 0 ? E : "" });
        })];
      });
    });
  }, t.prototype.createDoc = function(e, n) {
    return ze(this, void 0, void 0, function() {
      return Je(this, function(r) {
        return [2, this.axios.post("/api/resource/".concat(e), Z({}, n)).then(function(s) {
          return s.data.data;
        }).catch(function(s) {
          var i, o, c;
          throw Z(Z({}, s.response.data), { httpStatus: s.response.status, httpStatusText: s.response.statusText, message: (i = s.response.data.message) !== null && i !== void 0 ? i : "There was an error while creating the document.", exception: (c = (o = s.response.data.exception) !== null && o !== void 0 ? o : s.response.data.exc_type) !== null && c !== void 0 ? c : "" });
        })];
      });
    });
  }, t.prototype.updateDoc = function(e, n, r) {
    return ze(this, void 0, void 0, function() {
      return Je(this, function(s) {
        return [2, this.axios.put("/api/resource/".concat(e, "/").concat(n && encodeURIComponent(n)), Z({}, r)).then(function(i) {
          return i.data.data;
        }).catch(function(i) {
          var o, c, l;
          throw Z(Z({}, i.response.data), { httpStatus: i.response.status, httpStatusText: i.response.statusText, message: (o = i.response.data.message) !== null && o !== void 0 ? o : "There was an error while updating the document.", exception: (l = (c = i.response.data.exception) !== null && c !== void 0 ? c : i.response.data.exc_type) !== null && l !== void 0 ? l : "" });
        })];
      });
    });
  }, t.prototype.deleteDoc = function(e, n) {
    return ze(this, void 0, void 0, function() {
      return Je(this, function(r) {
        return [2, this.axios.delete("/api/resource/".concat(e, "/").concat(n && encodeURIComponent(n))).then(function(s) {
          return s.data;
        }).catch(function(s) {
          var i, o;
          throw Z(Z({}, s.response.data), { httpStatus: s.response.status, httpStatusText: s.response.statusText, message: "There was an error while deleting the document.", exception: (o = (i = s.response.data.exception) !== null && i !== void 0 ? i : s.response.data.exc_type) !== null && o !== void 0 ? o : "" });
        })];
      });
    });
  }, t.prototype.getCount = function(e, n, r, s) {
    return r === void 0 && (r = !1), s === void 0 && (s = !1), ze(this, void 0, void 0, function() {
      var i;
      return Je(this, function(o) {
        return i = {
          doctype: e,
          filters: []
        }, r && (i.cache = r), s && (i.debug = s), n && (i.filters = n ? JSON.stringify(n) : void 0), [2, this.axios.get("/api/method/frappe.client.get_count", { params: i }).then(function(c) {
          return c.data.message;
        }).catch(function(c) {
          var l, a;
          throw Z(Z({}, c.response.data), { httpStatus: c.response.status, httpStatusText: c.response.statusText, message: "There was an error while getting the count.", exception: (a = (l = c.response.data.exception) !== null && l !== void 0 ? l : c.response.data.exc_type) !== null && a !== void 0 ? a : "" });
        })];
      });
    });
  }, t.prototype.getLastDoc = function(e, n) {
    return ze(this, void 0, void 0, function() {
      var r, s;
      return Je(this, function(i) {
        switch (i.label) {
          case 0:
            return r = {
              orderBy: {
                field: "creation",
                order: "desc"
              }
            }, n && (r = Z(Z({}, r), n)), [4, this.getDocList(e, Z(Z({}, r), { limit: 1, fields: ["name"] }))];
          case 1:
            return s = i.sent(), s.length > 0 ? [2, this.getDoc(e, s[0].name)] : [2, {}];
        }
      });
    });
  }, t;
}();
Tt.FrappeDB = Di;
var Ot = {}, Ke = {};
function fs(t, e) {
  return function() {
    return t.apply(e, arguments);
  };
}
const { toString: Li } = Object.prototype, { getPrototypeOf: sr } = Object, tn = ((t) => (e) => {
  const n = Li.call(e);
  return t[n] || (t[n] = n.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Te = (t) => (t = t.toLowerCase(), (e) => tn(e) === t), nn = (t) => (e) => typeof e === t, { isArray: ct } = Array, Et = nn("undefined");
function Pi(t) {
  return t !== null && !Et(t) && t.constructor !== null && !Et(t.constructor) && de(t.constructor.isBuffer) && t.constructor.isBuffer(t);
}
const hs = Te("ArrayBuffer");
function ki(t) {
  let e;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(t) : e = t && t.buffer && hs(t.buffer), e;
}
const Ni = nn("string"), de = nn("function"), ds = nn("number"), rn = (t) => t !== null && typeof t == "object", Fi = (t) => t === !0 || t === !1, Mt = (t) => {
  if (tn(t) !== "object")
    return !1;
  const e = sr(t);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t);
}, Bi = Te("Date"), Ui = Te("File"), Ii = Te("Blob"), ji = Te("FileList"), qi = (t) => rn(t) && de(t.pipe), Vi = (t) => {
  let e;
  return t && (typeof FormData == "function" && t instanceof FormData || de(t.append) && ((e = tn(t)) === "formdata" || e === "object" && de(t.toString) && t.toString() === "[object FormData]"));
}, $i = Te("URLSearchParams"), [Mi, Hi, Wi, zi] = ["ReadableStream", "Request", "Response", "Headers"].map(Te), Ji = (t) => t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function xt(t, e, { allOwnKeys: n = !1 } = {}) {
  if (t === null || typeof t > "u")
    return;
  let r, s;
  if (typeof t != "object" && (t = [t]), ct(t))
    for (r = 0, s = t.length; r < s; r++)
      e.call(null, t[r], r, t);
  else {
    const i = n ? Object.getOwnPropertyNames(t) : Object.keys(t), o = i.length;
    let c;
    for (r = 0; r < o; r++)
      c = i[r], e.call(null, t[c], c, t);
  }
}
function ps(t, e) {
  e = e.toLowerCase();
  const n = Object.keys(t);
  let r = n.length, s;
  for (; r-- > 0; )
    if (s = n[r], e === s.toLowerCase())
      return s;
  return null;
}
const Ye = (() => typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : F)(), ms = (t) => !Et(t) && t !== Ye;
function Nn() {
  const { caseless: t } = ms(this) && this || {}, e = {}, n = (r, s) => {
    const i = t && ps(e, s) || s;
    Mt(e[i]) && Mt(r) ? e[i] = Nn(e[i], r) : Mt(r) ? e[i] = Nn({}, r) : ct(r) ? e[i] = r.slice() : e[i] = r;
  };
  for (let r = 0, s = arguments.length; r < s; r++)
    arguments[r] && xt(arguments[r], n);
  return e;
}
const Yi = (t, e, n, { allOwnKeys: r } = {}) => (xt(e, (s, i) => {
  n && de(s) ? t[i] = fs(s, n) : t[i] = s;
}, { allOwnKeys: r }), t), Ki = (t) => (t.charCodeAt(0) === 65279 && (t = t.slice(1)), t), Gi = (t, e, n, r) => {
  t.prototype = Object.create(e.prototype, r), t.prototype.constructor = t, Object.defineProperty(t, "super", {
    value: e.prototype
  }), n && Object.assign(t.prototype, n);
}, Xi = (t, e, n, r) => {
  let s, i, o;
  const c = {};
  if (e = e || {}, t == null)
    return e;
  do {
    for (s = Object.getOwnPropertyNames(t), i = s.length; i-- > 0; )
      o = s[i], (!r || r(o, t, e)) && !c[o] && (e[o] = t[o], c[o] = !0);
    t = n !== !1 && sr(t);
  } while (t && (!n || n(t, e)) && t !== Object.prototype);
  return e;
}, Qi = (t, e, n) => {
  t = String(t), (n === void 0 || n > t.length) && (n = t.length), n -= e.length;
  const r = t.indexOf(e, n);
  return r !== -1 && r === n;
}, Zi = (t) => {
  if (!t)
    return null;
  if (ct(t))
    return t;
  let e = t.length;
  if (!ds(e))
    return null;
  const n = new Array(e);
  for (; e-- > 0; )
    n[e] = t[e];
  return n;
}, eo = ((t) => (e) => t && e instanceof t)(typeof Uint8Array < "u" && sr(Uint8Array)), to = (t, e) => {
  const r = (t && t[Symbol.iterator]).call(t);
  let s;
  for (; (s = r.next()) && !s.done; ) {
    const i = s.value;
    e.call(t, i[0], i[1]);
  }
}, no = (t, e) => {
  let n;
  const r = [];
  for (; (n = t.exec(e)) !== null; )
    r.push(n);
  return r;
}, ro = Te("HTMLFormElement"), so = (t) => t.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(n, r, s) {
    return r.toUpperCase() + s;
  }
), Cr = (({ hasOwnProperty: t }) => (e, n) => t.call(e, n))(Object.prototype), io = Te("RegExp"), ys = (t, e) => {
  const n = Object.getOwnPropertyDescriptors(t), r = {};
  xt(n, (s, i) => {
    let o;
    (o = e(s, i, t)) !== !1 && (r[i] = o || s);
  }), Object.defineProperties(t, r);
}, oo = (t) => {
  ys(t, (e, n) => {
    if (de(t) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
      return !1;
    const r = t[n];
    if (!!de(r)) {
      if (e.enumerable = !1, "writable" in e) {
        e.writable = !1;
        return;
      }
      e.set || (e.set = () => {
        throw Error("Can not rewrite read-only method '" + n + "'");
      });
    }
  });
}, ao = (t, e) => {
  const n = {}, r = (s) => {
    s.forEach((i) => {
      n[i] = !0;
    });
  };
  return ct(t) ? r(t) : r(String(t).split(e)), n;
}, co = () => {
}, uo = (t, e) => t != null && Number.isFinite(t = +t) ? t : e, wn = "abcdefghijklmnopqrstuvwxyz", Ar = "0123456789", gs = {
  DIGIT: Ar,
  ALPHA: wn,
  ALPHA_DIGIT: wn + wn.toUpperCase() + Ar
}, lo = (t = 16, e = gs.ALPHA_DIGIT) => {
  let n = "";
  const { length: r } = e;
  for (; t--; )
    n += e[Math.random() * r | 0];
  return n;
};
function fo(t) {
  return !!(t && de(t.append) && t[Symbol.toStringTag] === "FormData" && t[Symbol.iterator]);
}
const ho = (t) => {
  const e = new Array(10), n = (r, s) => {
    if (rn(r)) {
      if (e.indexOf(r) >= 0)
        return;
      if (!("toJSON" in r)) {
        e[s] = r;
        const i = ct(r) ? [] : {};
        return xt(r, (o, c) => {
          const l = n(o, s + 1);
          !Et(l) && (i[c] = l);
        }), e[s] = void 0, i;
      }
    }
    return r;
  };
  return n(t, 0);
}, po = Te("AsyncFunction"), mo = (t) => t && (rn(t) || de(t)) && de(t.then) && de(t.catch), vs = ((t, e) => t ? setImmediate : e ? ((n, r) => (Ye.addEventListener("message", ({ source: s, data: i }) => {
  s === Ye && i === n && r.length && r.shift()();
}, !1), (s) => {
  r.push(s), Ye.postMessage(n, "*");
}))(`axios@${Math.random()}`, []) : (n) => setTimeout(n))(
  typeof setImmediate == "function",
  de(Ye.postMessage)
), yo = typeof queueMicrotask < "u" ? queueMicrotask.bind(Ye) : typeof process < "u" && process.nextTick || vs;
var d = {
  isArray: ct,
  isArrayBuffer: hs,
  isBuffer: Pi,
  isFormData: Vi,
  isArrayBufferView: ki,
  isString: Ni,
  isNumber: ds,
  isBoolean: Fi,
  isObject: rn,
  isPlainObject: Mt,
  isReadableStream: Mi,
  isRequest: Hi,
  isResponse: Wi,
  isHeaders: zi,
  isUndefined: Et,
  isDate: Bi,
  isFile: Ui,
  isBlob: Ii,
  isRegExp: io,
  isFunction: de,
  isStream: qi,
  isURLSearchParams: $i,
  isTypedArray: eo,
  isFileList: ji,
  forEach: xt,
  merge: Nn,
  extend: Yi,
  trim: Ji,
  stripBOM: Ki,
  inherits: Gi,
  toFlatObject: Xi,
  kindOf: tn,
  kindOfTest: Te,
  endsWith: Qi,
  toArray: Zi,
  forEachEntry: to,
  matchAll: no,
  isHTMLForm: ro,
  hasOwnProperty: Cr,
  hasOwnProp: Cr,
  reduceDescriptors: ys,
  freezeMethods: oo,
  toObjectSet: ao,
  toCamelCase: so,
  noop: co,
  toFiniteNumber: uo,
  findKey: ps,
  global: Ye,
  isContextDefined: ms,
  ALPHABET: gs,
  generateString: lo,
  isSpecCompliantForm: fo,
  toJSONObject: ho,
  isAsyncFn: po,
  isThenable: mo,
  setImmediate: vs,
  asap: yo
};
function O(t, e, n, r, s) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = t, this.name = "AxiosError", e && (this.code = e), n && (this.config = n), r && (this.request = r), s && (this.response = s);
}
d.inherits(O, Error, {
  toJSON: function() {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: d.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const ws = O.prototype, bs = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
].forEach((t) => {
  bs[t] = { value: t };
});
Object.defineProperties(O, bs);
Object.defineProperty(ws, "isAxiosError", { value: !0 });
O.from = (t, e, n, r, s, i) => {
  const o = Object.create(ws);
  return d.toFlatObject(t, o, function(l) {
    return l !== Error.prototype;
  }, (c) => c !== "isAxiosError"), O.call(o, t.message, e, n, r, s), o.cause = t, o.name = t.name, i && Object.assign(o, i), o;
};
var go = null;
function Fn(t) {
  return d.isPlainObject(t) || d.isArray(t);
}
function _s(t) {
  return d.endsWith(t, "[]") ? t.slice(0, -2) : t;
}
function Dr(t, e, n) {
  return t ? t.concat(e).map(function(s, i) {
    return s = _s(s), !n && i ? "[" + s + "]" : s;
  }).join(n ? "." : "") : e;
}
function vo(t) {
  return d.isArray(t) && !t.some(Fn);
}
const wo = d.toFlatObject(d, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function sn(t, e, n) {
  if (!d.isObject(t))
    throw new TypeError("target must be an object");
  e = e || new FormData(), n = d.toFlatObject(n, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(g, w) {
    return !d.isUndefined(w[g]);
  });
  const r = n.metaTokens, s = n.visitor || f, i = n.dots, o = n.indexes, l = (n.Blob || typeof Blob < "u" && Blob) && d.isSpecCompliantForm(e);
  if (!d.isFunction(s))
    throw new TypeError("visitor must be a function");
  function a(p) {
    if (p === null)
      return "";
    if (d.isDate(p))
      return p.toISOString();
    if (!l && d.isBlob(p))
      throw new O("Blob is not supported. Use a Buffer instead.");
    return d.isArrayBuffer(p) || d.isTypedArray(p) ? l && typeof Blob == "function" ? new Blob([p]) : Buffer.from(p) : p;
  }
  function f(p, g, w) {
    let b = p;
    if (p && !w && typeof p == "object") {
      if (d.endsWith(g, "{}"))
        g = r ? g : g.slice(0, -2), p = JSON.stringify(p);
      else if (d.isArray(p) && vo(p) || (d.isFileList(p) || d.endsWith(g, "[]")) && (b = d.toArray(p)))
        return g = _s(g), b.forEach(function(S, M) {
          !(d.isUndefined(S) || S === null) && e.append(
            o === !0 ? Dr([g], M, i) : o === null ? g : g + "[]",
            a(S)
          );
        }), !1;
    }
    return Fn(p) ? !0 : (e.append(Dr(w, g, i), a(p)), !1);
  }
  const h = [], y = Object.assign(wo, {
    defaultVisitor: f,
    convertValue: a,
    isVisitable: Fn
  });
  function m(p, g) {
    if (!d.isUndefined(p)) {
      if (h.indexOf(p) !== -1)
        throw Error("Circular reference detected in " + g.join("."));
      h.push(p), d.forEach(p, function(b, E) {
        (!(d.isUndefined(b) || b === null) && s.call(
          e,
          b,
          d.isString(E) ? E.trim() : E,
          g,
          y
        )) === !0 && m(b, g ? g.concat(E) : [E]);
      }), h.pop();
    }
  }
  if (!d.isObject(t))
    throw new TypeError("data must be an object");
  return m(t), e;
}
function Lr(t) {
  const e = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function(r) {
    return e[r];
  });
}
function ir(t, e) {
  this._pairs = [], t && sn(t, this, e);
}
const Es = ir.prototype;
Es.append = function(e, n) {
  this._pairs.push([e, n]);
};
Es.toString = function(e) {
  const n = e ? function(r) {
    return e.call(this, r, Lr);
  } : Lr;
  return this._pairs.map(function(s) {
    return n(s[0]) + "=" + n(s[1]);
  }, "").join("&");
};
function bo(t) {
  return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function Rs(t, e, n) {
  if (!e)
    return t;
  const r = n && n.encode || bo, s = n && n.serialize;
  let i;
  if (s ? i = s(e, n) : i = d.isURLSearchParams(e) ? e.toString() : new ir(e, n).toString(r), i) {
    const o = t.indexOf("#");
    o !== -1 && (t = t.slice(0, o)), t += (t.indexOf("?") === -1 ? "?" : "&") + i;
  }
  return t;
}
class _o {
  constructor() {
    this.handlers = [];
  }
  use(e, n, r) {
    return this.handlers.push({
      fulfilled: e,
      rejected: n,
      synchronous: r ? r.synchronous : !1,
      runWhen: r ? r.runWhen : null
    }), this.handlers.length - 1;
  }
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null);
  }
  clear() {
    this.handlers && (this.handlers = []);
  }
  forEach(e) {
    d.forEach(this.handlers, function(r) {
      r !== null && e(r);
    });
  }
}
var Pr = _o, Ss = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, Eo = typeof URLSearchParams < "u" ? URLSearchParams : ir, Ro = typeof FormData < "u" ? FormData : null, So = typeof Blob < "u" ? Blob : null, To = {
  isBrowser: !0,
  classes: {
    URLSearchParams: Eo,
    FormData: Ro,
    Blob: So
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
const or = typeof window < "u" && typeof document < "u", Oo = ((t) => or && ["ReactNative", "NativeScript", "NS"].indexOf(t) < 0)(typeof navigator < "u" && navigator.product), xo = (() => typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function")(), Co = or && window.location.href || "http://localhost";
var Ao = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  hasBrowserEnv: or,
  hasStandardBrowserWebWorkerEnv: xo,
  hasStandardBrowserEnv: Oo,
  origin: Co
}), Re = {
  ...Ao,
  ...To
};
function Do(t, e) {
  return sn(t, new Re.classes.URLSearchParams(), Object.assign({
    visitor: function(n, r, s, i) {
      return Re.isNode && d.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : i.defaultVisitor.apply(this, arguments);
    }
  }, e));
}
function Lo(t) {
  return d.matchAll(/\w+|\[(\w*)]/g, t).map((e) => e[0] === "[]" ? "" : e[1] || e[0]);
}
function Po(t) {
  const e = {}, n = Object.keys(t);
  let r;
  const s = n.length;
  let i;
  for (r = 0; r < s; r++)
    i = n[r], e[i] = t[i];
  return e;
}
function Ts(t) {
  function e(n, r, s, i) {
    let o = n[i++];
    if (o === "__proto__")
      return !0;
    const c = Number.isFinite(+o), l = i >= n.length;
    return o = !o && d.isArray(s) ? s.length : o, l ? (d.hasOwnProp(s, o) ? s[o] = [s[o], r] : s[o] = r, !c) : ((!s[o] || !d.isObject(s[o])) && (s[o] = []), e(n, r, s[o], i) && d.isArray(s[o]) && (s[o] = Po(s[o])), !c);
  }
  if (d.isFormData(t) && d.isFunction(t.entries)) {
    const n = {};
    return d.forEachEntry(t, (r, s) => {
      e(Lo(r), s, n, 0);
    }), n;
  }
  return null;
}
function ko(t, e, n) {
  if (d.isString(t))
    try {
      return (e || JSON.parse)(t), d.trim(t);
    } catch (r) {
      if (r.name !== "SyntaxError")
        throw r;
    }
  return (n || JSON.stringify)(t);
}
const ar = {
  transitional: Ss,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(e, n) {
    const r = n.getContentType() || "", s = r.indexOf("application/json") > -1, i = d.isObject(e);
    if (i && d.isHTMLForm(e) && (e = new FormData(e)), d.isFormData(e))
      return s ? JSON.stringify(Ts(e)) : e;
    if (d.isArrayBuffer(e) || d.isBuffer(e) || d.isStream(e) || d.isFile(e) || d.isBlob(e) || d.isReadableStream(e))
      return e;
    if (d.isArrayBufferView(e))
      return e.buffer;
    if (d.isURLSearchParams(e))
      return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
    let c;
    if (i) {
      if (r.indexOf("application/x-www-form-urlencoded") > -1)
        return Do(e, this.formSerializer).toString();
      if ((c = d.isFileList(e)) || r.indexOf("multipart/form-data") > -1) {
        const l = this.env && this.env.FormData;
        return sn(
          c ? { "files[]": e } : e,
          l && new l(),
          this.formSerializer
        );
      }
    }
    return i || s ? (n.setContentType("application/json", !1), ko(e)) : e;
  }],
  transformResponse: [function(e) {
    const n = this.transitional || ar.transitional, r = n && n.forcedJSONParsing, s = this.responseType === "json";
    if (d.isResponse(e) || d.isReadableStream(e))
      return e;
    if (e && d.isString(e) && (r && !this.responseType || s)) {
      const o = !(n && n.silentJSONParsing) && s;
      try {
        return JSON.parse(e);
      } catch (c) {
        if (o)
          throw c.name === "SyntaxError" ? O.from(c, O.ERR_BAD_RESPONSE, this, null, this.response) : c;
      }
    }
    return e;
  }],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: Re.classes.FormData,
    Blob: Re.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
d.forEach(["delete", "get", "head", "post", "put", "patch"], (t) => {
  ar.headers[t] = {};
});
var cr = ar;
const No = d.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var Fo = (t) => {
  const e = {};
  let n, r, s;
  return t && t.split(`
`).forEach(function(o) {
    s = o.indexOf(":"), n = o.substring(0, s).trim().toLowerCase(), r = o.substring(s + 1).trim(), !(!n || e[n] && No[n]) && (n === "set-cookie" ? e[n] ? e[n].push(r) : e[n] = [r] : e[n] = e[n] ? e[n] + ", " + r : r);
  }), e;
};
const kr = Symbol("internals");
function mt(t) {
  return t && String(t).trim().toLowerCase();
}
function Ht(t) {
  return t === !1 || t == null ? t : d.isArray(t) ? t.map(Ht) : String(t);
}
function Bo(t) {
  const e = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let r;
  for (; r = n.exec(t); )
    e[r[1]] = r[2];
  return e;
}
const Uo = (t) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim());
function bn(t, e, n, r, s) {
  if (d.isFunction(r))
    return r.call(this, e, n);
  if (s && (e = n), !!d.isString(e)) {
    if (d.isString(r))
      return e.indexOf(r) !== -1;
    if (d.isRegExp(r))
      return r.test(e);
  }
}
function Io(t) {
  return t.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, n, r) => n.toUpperCase() + r);
}
function jo(t, e) {
  const n = d.toCamelCase(" " + e);
  ["get", "set", "has"].forEach((r) => {
    Object.defineProperty(t, r + n, {
      value: function(s, i, o) {
        return this[r].call(this, e, s, i, o);
      },
      configurable: !0
    });
  });
}
class on {
  constructor(e) {
    e && this.set(e);
  }
  set(e, n, r) {
    const s = this;
    function i(c, l, a) {
      const f = mt(l);
      if (!f)
        throw new Error("header name must be a non-empty string");
      const h = d.findKey(s, f);
      (!h || s[h] === void 0 || a === !0 || a === void 0 && s[h] !== !1) && (s[h || l] = Ht(c));
    }
    const o = (c, l) => d.forEach(c, (a, f) => i(a, f, l));
    if (d.isPlainObject(e) || e instanceof this.constructor)
      o(e, n);
    else if (d.isString(e) && (e = e.trim()) && !Uo(e))
      o(Fo(e), n);
    else if (d.isHeaders(e))
      for (const [c, l] of e.entries())
        i(l, c, r);
    else
      e != null && i(n, e, r);
    return this;
  }
  get(e, n) {
    if (e = mt(e), e) {
      const r = d.findKey(this, e);
      if (r) {
        const s = this[r];
        if (!n)
          return s;
        if (n === !0)
          return Bo(s);
        if (d.isFunction(n))
          return n.call(this, s, r);
        if (d.isRegExp(n))
          return n.exec(s);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, n) {
    if (e = mt(e), e) {
      const r = d.findKey(this, e);
      return !!(r && this[r] !== void 0 && (!n || bn(this, this[r], r, n)));
    }
    return !1;
  }
  delete(e, n) {
    const r = this;
    let s = !1;
    function i(o) {
      if (o = mt(o), o) {
        const c = d.findKey(r, o);
        c && (!n || bn(r, r[c], c, n)) && (delete r[c], s = !0);
      }
    }
    return d.isArray(e) ? e.forEach(i) : i(e), s;
  }
  clear(e) {
    const n = Object.keys(this);
    let r = n.length, s = !1;
    for (; r--; ) {
      const i = n[r];
      (!e || bn(this, this[i], i, e, !0)) && (delete this[i], s = !0);
    }
    return s;
  }
  normalize(e) {
    const n = this, r = {};
    return d.forEach(this, (s, i) => {
      const o = d.findKey(r, i);
      if (o) {
        n[o] = Ht(s), delete n[i];
        return;
      }
      const c = e ? Io(i) : String(i).trim();
      c !== i && delete n[i], n[c] = Ht(s), r[c] = !0;
    }), this;
  }
  concat(...e) {
    return this.constructor.concat(this, ...e);
  }
  toJSON(e) {
    const n = /* @__PURE__ */ Object.create(null);
    return d.forEach(this, (r, s) => {
      r != null && r !== !1 && (n[s] = e && d.isArray(r) ? r.join(", ") : r);
    }), n;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([e, n]) => e + ": " + n).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e, ...n) {
    const r = new this(e);
    return n.forEach((s) => r.set(s)), r;
  }
  static accessor(e) {
    const r = (this[kr] = this[kr] = {
      accessors: {}
    }).accessors, s = this.prototype;
    function i(o) {
      const c = mt(o);
      r[c] || (jo(s, o), r[c] = !0);
    }
    return d.isArray(e) ? e.forEach(i) : i(e), this;
  }
}
on.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
d.reduceDescriptors(on.prototype, ({ value: t }, e) => {
  let n = e[0].toUpperCase() + e.slice(1);
  return {
    get: () => t,
    set(r) {
      this[n] = r;
    }
  };
});
d.freezeMethods(on);
var Se = on;
function _n(t, e) {
  const n = this || cr, r = e || n, s = Se.from(r.headers);
  let i = r.data;
  return d.forEach(t, function(c) {
    i = c.call(n, i, s.normalize(), e ? e.status : void 0);
  }), s.normalize(), i;
}
function Os(t) {
  return !!(t && t.__CANCEL__);
}
function ut(t, e, n) {
  O.call(this, t == null ? "canceled" : t, O.ERR_CANCELED, e, n), this.name = "CanceledError";
}
d.inherits(ut, O, {
  __CANCEL__: !0
});
function xs(t, e, n) {
  const r = n.config.validateStatus;
  !n.status || !r || r(n.status) ? t(n) : e(new O(
    "Request failed with status code " + n.status,
    [O.ERR_BAD_REQUEST, O.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
    n.config,
    n.request,
    n
  ));
}
function qo(t) {
  const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
  return e && e[1] || "";
}
function Vo(t, e) {
  t = t || 10;
  const n = new Array(t), r = new Array(t);
  let s = 0, i = 0, o;
  return e = e !== void 0 ? e : 1e3, function(l) {
    const a = Date.now(), f = r[i];
    o || (o = a), n[s] = l, r[s] = a;
    let h = i, y = 0;
    for (; h !== s; )
      y += n[h++], h = h % t;
    if (s = (s + 1) % t, s === i && (i = (i + 1) % t), a - o < e)
      return;
    const m = f && a - f;
    return m ? Math.round(y * 1e3 / m) : void 0;
  };
}
function $o(t, e) {
  let n = 0, r = 1e3 / e, s, i;
  const o = (a, f = Date.now()) => {
    n = f, s = null, i && (clearTimeout(i), i = null), t.apply(null, a);
  };
  return [(...a) => {
    const f = Date.now(), h = f - n;
    h >= r ? o(a, f) : (s = a, i || (i = setTimeout(() => {
      i = null, o(s);
    }, r - h)));
  }, () => s && o(s)];
}
const Gt = (t, e, n = 3) => {
  let r = 0;
  const s = Vo(50, 250);
  return $o((i) => {
    const o = i.loaded, c = i.lengthComputable ? i.total : void 0, l = o - r, a = s(l), f = o <= c;
    r = o;
    const h = {
      loaded: o,
      total: c,
      progress: c ? o / c : void 0,
      bytes: l,
      rate: a || void 0,
      estimated: a && c && f ? (c - o) / a : void 0,
      event: i,
      lengthComputable: c != null,
      [e ? "download" : "upload"]: !0
    };
    t(h);
  }, n);
}, Nr = (t, e) => {
  const n = t != null;
  return [(r) => e[0]({
    lengthComputable: n,
    total: t,
    loaded: r
  }), e[1]];
}, Fr = (t) => (...e) => d.asap(() => t(...e));
var Mo = Re.hasStandardBrowserEnv ? function() {
  const e = /(msie|trident)/i.test(navigator.userAgent), n = document.createElement("a");
  let r;
  function s(i) {
    let o = i;
    return e && (n.setAttribute("href", o), o = n.href), n.setAttribute("href", o), {
      href: n.href,
      protocol: n.protocol ? n.protocol.replace(/:$/, "") : "",
      host: n.host,
      search: n.search ? n.search.replace(/^\?/, "") : "",
      hash: n.hash ? n.hash.replace(/^#/, "") : "",
      hostname: n.hostname,
      port: n.port,
      pathname: n.pathname.charAt(0) === "/" ? n.pathname : "/" + n.pathname
    };
  }
  return r = s(window.location.href), function(o) {
    const c = d.isString(o) ? s(o) : o;
    return c.protocol === r.protocol && c.host === r.host;
  };
}() : function() {
  return function() {
    return !0;
  };
}(), Ho = Re.hasStandardBrowserEnv ? {
  write(t, e, n, r, s, i) {
    const o = [t + "=" + encodeURIComponent(e)];
    d.isNumber(n) && o.push("expires=" + new Date(n).toGMTString()), d.isString(r) && o.push("path=" + r), d.isString(s) && o.push("domain=" + s), i === !0 && o.push("secure"), document.cookie = o.join("; ");
  },
  read(t) {
    const e = document.cookie.match(new RegExp("(^|;\\s*)(" + t + ")=([^;]*)"));
    return e ? decodeURIComponent(e[3]) : null;
  },
  remove(t) {
    this.write(t, "", Date.now() - 864e5);
  }
} : {
  write() {
  },
  read() {
    return null;
  },
  remove() {
  }
};
function Wo(t) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t);
}
function zo(t, e) {
  return e ? t.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : t;
}
function Cs(t, e) {
  return t && !Wo(e) ? zo(t, e) : e;
}
const Br = (t) => t instanceof Se ? { ...t } : t;
function Ge(t, e) {
  e = e || {};
  const n = {};
  function r(a, f, h) {
    return d.isPlainObject(a) && d.isPlainObject(f) ? d.merge.call({ caseless: h }, a, f) : d.isPlainObject(f) ? d.merge({}, f) : d.isArray(f) ? f.slice() : f;
  }
  function s(a, f, h) {
    if (d.isUndefined(f)) {
      if (!d.isUndefined(a))
        return r(void 0, a, h);
    } else
      return r(a, f, h);
  }
  function i(a, f) {
    if (!d.isUndefined(f))
      return r(void 0, f);
  }
  function o(a, f) {
    if (d.isUndefined(f)) {
      if (!d.isUndefined(a))
        return r(void 0, a);
    } else
      return r(void 0, f);
  }
  function c(a, f, h) {
    if (h in e)
      return r(a, f);
    if (h in t)
      return r(void 0, a);
  }
  const l = {
    url: i,
    method: i,
    data: i,
    baseURL: o,
    transformRequest: o,
    transformResponse: o,
    paramsSerializer: o,
    timeout: o,
    timeoutMessage: o,
    withCredentials: o,
    withXSRFToken: o,
    adapter: o,
    responseType: o,
    xsrfCookieName: o,
    xsrfHeaderName: o,
    onUploadProgress: o,
    onDownloadProgress: o,
    decompress: o,
    maxContentLength: o,
    maxBodyLength: o,
    beforeRedirect: o,
    transport: o,
    httpAgent: o,
    httpsAgent: o,
    cancelToken: o,
    socketPath: o,
    responseEncoding: o,
    validateStatus: c,
    headers: (a, f) => s(Br(a), Br(f), !0)
  };
  return d.forEach(Object.keys(Object.assign({}, t, e)), function(f) {
    const h = l[f] || s, y = h(t[f], e[f], f);
    d.isUndefined(y) && h !== c || (n[f] = y);
  }), n;
}
var As = (t) => {
  const e = Ge({}, t);
  let { data: n, withXSRFToken: r, xsrfHeaderName: s, xsrfCookieName: i, headers: o, auth: c } = e;
  e.headers = o = Se.from(o), e.url = Rs(Cs(e.baseURL, e.url), t.params, t.paramsSerializer), c && o.set(
    "Authorization",
    "Basic " + btoa((c.username || "") + ":" + (c.password ? unescape(encodeURIComponent(c.password)) : ""))
  );
  let l;
  if (d.isFormData(n)) {
    if (Re.hasStandardBrowserEnv || Re.hasStandardBrowserWebWorkerEnv)
      o.setContentType(void 0);
    else if ((l = o.getContentType()) !== !1) {
      const [a, ...f] = l ? l.split(";").map((h) => h.trim()).filter(Boolean) : [];
      o.setContentType([a || "multipart/form-data", ...f].join("; "));
    }
  }
  if (Re.hasStandardBrowserEnv && (r && d.isFunction(r) && (r = r(e)), r || r !== !1 && Mo(e.url))) {
    const a = s && i && Ho.read(i);
    a && o.set(s, a);
  }
  return e;
};
const Jo = typeof XMLHttpRequest < "u";
var Yo = Jo && function(t) {
  return new Promise(function(n, r) {
    const s = As(t);
    let i = s.data;
    const o = Se.from(s.headers).normalize();
    let { responseType: c, onUploadProgress: l, onDownloadProgress: a } = s, f, h, y, m, p;
    function g() {
      m && m(), p && p(), s.cancelToken && s.cancelToken.unsubscribe(f), s.signal && s.signal.removeEventListener("abort", f);
    }
    let w = new XMLHttpRequest();
    w.open(s.method.toUpperCase(), s.url, !0), w.timeout = s.timeout;
    function b() {
      if (!w)
        return;
      const S = Se.from(
        "getAllResponseHeaders" in w && w.getAllResponseHeaders()
      ), L = {
        data: !c || c === "text" || c === "json" ? w.responseText : w.response,
        status: w.status,
        statusText: w.statusText,
        headers: S,
        config: t,
        request: w
      };
      xs(function(z) {
        n(z), g();
      }, function(z) {
        r(z), g();
      }, L), w = null;
    }
    "onloadend" in w ? w.onloadend = b : w.onreadystatechange = function() {
      !w || w.readyState !== 4 || w.status === 0 && !(w.responseURL && w.responseURL.indexOf("file:") === 0) || setTimeout(b);
    }, w.onabort = function() {
      !w || (r(new O("Request aborted", O.ECONNABORTED, t, w)), w = null);
    }, w.onerror = function() {
      r(new O("Network Error", O.ERR_NETWORK, t, w)), w = null;
    }, w.ontimeout = function() {
      let M = s.timeout ? "timeout of " + s.timeout + "ms exceeded" : "timeout exceeded";
      const L = s.transitional || Ss;
      s.timeoutErrorMessage && (M = s.timeoutErrorMessage), r(new O(
        M,
        L.clarifyTimeoutError ? O.ETIMEDOUT : O.ECONNABORTED,
        t,
        w
      )), w = null;
    }, i === void 0 && o.setContentType(null), "setRequestHeader" in w && d.forEach(o.toJSON(), function(M, L) {
      w.setRequestHeader(L, M);
    }), d.isUndefined(s.withCredentials) || (w.withCredentials = !!s.withCredentials), c && c !== "json" && (w.responseType = s.responseType), a && ([y, p] = Gt(a, !0), w.addEventListener("progress", y)), l && w.upload && ([h, m] = Gt(l), w.upload.addEventListener("progress", h), w.upload.addEventListener("loadend", m)), (s.cancelToken || s.signal) && (f = (S) => {
      !w || (r(!S || S.type ? new ut(null, t, w) : S), w.abort(), w = null);
    }, s.cancelToken && s.cancelToken.subscribe(f), s.signal && (s.signal.aborted ? f() : s.signal.addEventListener("abort", f)));
    const E = qo(s.url);
    if (E && Re.protocols.indexOf(E) === -1) {
      r(new O("Unsupported protocol " + E + ":", O.ERR_BAD_REQUEST, t));
      return;
    }
    w.send(i || null);
  });
};
const Ko = (t, e) => {
  let n = new AbortController(), r;
  const s = function(l) {
    if (!r) {
      r = !0, o();
      const a = l instanceof Error ? l : this.reason;
      n.abort(a instanceof O ? a : new ut(a instanceof Error ? a.message : a));
    }
  };
  let i = e && setTimeout(() => {
    s(new O(`timeout ${e} of ms exceeded`, O.ETIMEDOUT));
  }, e);
  const o = () => {
    t && (i && clearTimeout(i), i = null, t.forEach((l) => {
      l && (l.removeEventListener ? l.removeEventListener("abort", s) : l.unsubscribe(s));
    }), t = null);
  };
  t.forEach((l) => l && l.addEventListener && l.addEventListener("abort", s));
  const { signal: c } = n;
  return c.unsubscribe = o, [c, () => {
    i && clearTimeout(i), i = null;
  }];
};
var Go = Ko;
const Xo = function* (t, e) {
  let n = t.byteLength;
  if (!e || n < e) {
    yield t;
    return;
  }
  let r = 0, s;
  for (; r < n; )
    s = r + e, yield t.slice(r, s), r = s;
}, Qo = async function* (t, e, n) {
  for await (const r of t)
    yield* Xo(ArrayBuffer.isView(r) ? r : await n(String(r)), e);
}, Ur = (t, e, n, r, s) => {
  const i = Qo(t, e, s);
  let o = 0, c, l = (a) => {
    c || (c = !0, r && r(a));
  };
  return new ReadableStream({
    async pull(a) {
      try {
        const { done: f, value: h } = await i.next();
        if (f) {
          l(), a.close();
          return;
        }
        let y = h.byteLength;
        if (n) {
          let m = o += y;
          n(m);
        }
        a.enqueue(new Uint8Array(h));
      } catch (f) {
        throw l(f), f;
      }
    },
    cancel(a) {
      return l(a), i.return();
    }
  }, {
    highWaterMark: 2
  });
}, an = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", Ds = an && typeof ReadableStream == "function", Bn = an && (typeof TextEncoder == "function" ? ((t) => (e) => t.encode(e))(new TextEncoder()) : async (t) => new Uint8Array(await new Response(t).arrayBuffer())), Ls = (t, ...e) => {
  try {
    return !!t(...e);
  } catch {
    return !1;
  }
}, Zo = Ds && Ls(() => {
  let t = !1;
  const e = new Request(Re.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return t = !0, "half";
    }
  }).headers.has("Content-Type");
  return t && !e;
}), Ir = 64 * 1024, Un = Ds && Ls(() => d.isReadableStream(new Response("").body)), Xt = {
  stream: Un && ((t) => t.body)
};
an && ((t) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((e) => {
    !Xt[e] && (Xt[e] = d.isFunction(t[e]) ? (n) => n[e]() : (n, r) => {
      throw new O(`Response type '${e}' is not supported`, O.ERR_NOT_SUPPORT, r);
    });
  });
})(new Response());
const ea = async (t) => {
  if (t == null)
    return 0;
  if (d.isBlob(t))
    return t.size;
  if (d.isSpecCompliantForm(t))
    return (await new Request(t).arrayBuffer()).byteLength;
  if (d.isArrayBufferView(t) || d.isArrayBuffer(t))
    return t.byteLength;
  if (d.isURLSearchParams(t) && (t = t + ""), d.isString(t))
    return (await Bn(t)).byteLength;
}, ta = async (t, e) => {
  const n = d.toFiniteNumber(t.getContentLength());
  return n == null ? ea(e) : n;
};
var na = an && (async (t) => {
  let {
    url: e,
    method: n,
    data: r,
    signal: s,
    cancelToken: i,
    timeout: o,
    onDownloadProgress: c,
    onUploadProgress: l,
    responseType: a,
    headers: f,
    withCredentials: h = "same-origin",
    fetchOptions: y
  } = As(t);
  a = a ? (a + "").toLowerCase() : "text";
  let [m, p] = s || i || o ? Go([s, i], o) : [], g, w;
  const b = () => {
    !g && setTimeout(() => {
      m && m.unsubscribe();
    }), g = !0;
  };
  let E;
  try {
    if (l && Zo && n !== "get" && n !== "head" && (E = await ta(f, r)) !== 0) {
      let k = new Request(e, {
        method: "POST",
        body: r,
        duplex: "half"
      }), z;
      if (d.isFormData(r) && (z = k.headers.get("content-type")) && f.setContentType(z), k.body) {
        const [T, W] = Nr(
          E,
          Gt(Fr(l))
        );
        r = Ur(k.body, Ir, T, W, Bn);
      }
    }
    d.isString(h) || (h = h ? "include" : "omit"), w = new Request(e, {
      ...y,
      signal: m,
      method: n.toUpperCase(),
      headers: f.normalize().toJSON(),
      body: r,
      duplex: "half",
      credentials: h
    });
    let S = await fetch(w);
    const M = Un && (a === "stream" || a === "response");
    if (Un && (c || M)) {
      const k = {};
      ["status", "statusText", "headers"].forEach((B) => {
        k[B] = S[B];
      });
      const z = d.toFiniteNumber(S.headers.get("content-length")), [T, W] = c && Nr(
        z,
        Gt(Fr(c), !0)
      ) || [];
      S = new Response(
        Ur(S.body, Ir, T, () => {
          W && W(), M && b();
        }, Bn),
        k
      );
    }
    a = a || "text";
    let L = await Xt[d.findKey(Xt, a) || "text"](S, t);
    return !M && b(), p && p(), await new Promise((k, z) => {
      xs(k, z, {
        data: L,
        headers: Se.from(S.headers),
        status: S.status,
        statusText: S.statusText,
        config: t,
        request: w
      });
    });
  } catch (S) {
    throw b(), S && S.name === "TypeError" && /fetch/i.test(S.message) ? Object.assign(
      new O("Network Error", O.ERR_NETWORK, t, w),
      {
        cause: S.cause || S
      }
    ) : O.from(S, S && S.code, t, w);
  }
});
const In = {
  http: go,
  xhr: Yo,
  fetch: na
};
d.forEach(In, (t, e) => {
  if (t) {
    try {
      Object.defineProperty(t, "name", { value: e });
    } catch {
    }
    Object.defineProperty(t, "adapterName", { value: e });
  }
});
const jr = (t) => `- ${t}`, ra = (t) => d.isFunction(t) || t === null || t === !1;
var Ps = {
  getAdapter: (t) => {
    t = d.isArray(t) ? t : [t];
    const { length: e } = t;
    let n, r;
    const s = {};
    for (let i = 0; i < e; i++) {
      n = t[i];
      let o;
      if (r = n, !ra(n) && (r = In[(o = String(n)).toLowerCase()], r === void 0))
        throw new O(`Unknown adapter '${o}'`);
      if (r)
        break;
      s[o || "#" + i] = r;
    }
    if (!r) {
      const i = Object.entries(s).map(
        ([c, l]) => `adapter ${c} ` + (l === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let o = e ? i.length > 1 ? `since :
` + i.map(jr).join(`
`) : " " + jr(i[0]) : "as no adapter specified";
      throw new O(
        "There is no suitable adapter to dispatch the request " + o,
        "ERR_NOT_SUPPORT"
      );
    }
    return r;
  },
  adapters: In
};
function En(t) {
  if (t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted)
    throw new ut(null, t);
}
function qr(t) {
  return En(t), t.headers = Se.from(t.headers), t.data = _n.call(
    t,
    t.transformRequest
  ), ["post", "put", "patch"].indexOf(t.method) !== -1 && t.headers.setContentType("application/x-www-form-urlencoded", !1), Ps.getAdapter(t.adapter || cr.adapter)(t).then(function(r) {
    return En(t), r.data = _n.call(
      t,
      t.transformResponse,
      r
    ), r.headers = Se.from(r.headers), r;
  }, function(r) {
    return Os(r) || (En(t), r && r.response && (r.response.data = _n.call(
      t,
      t.transformResponse,
      r.response
    ), r.response.headers = Se.from(r.response.headers))), Promise.reject(r);
  });
}
const ks = "1.7.4", ur = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((t, e) => {
  ur[t] = function(r) {
    return typeof r === t || "a" + (e < 1 ? "n " : " ") + t;
  };
});
const Vr = {};
ur.transitional = function(e, n, r) {
  function s(i, o) {
    return "[Axios v" + ks + "] Transitional option '" + i + "'" + o + (r ? ". " + r : "");
  }
  return (i, o, c) => {
    if (e === !1)
      throw new O(
        s(o, " has been removed" + (n ? " in " + n : "")),
        O.ERR_DEPRECATED
      );
    return n && !Vr[o] && (Vr[o] = !0, console.warn(
      s(
        o,
        " has been deprecated since v" + n + " and will be removed in the near future"
      )
    )), e ? e(i, o, c) : !0;
  };
};
function sa(t, e, n) {
  if (typeof t != "object")
    throw new O("options must be an object", O.ERR_BAD_OPTION_VALUE);
  const r = Object.keys(t);
  let s = r.length;
  for (; s-- > 0; ) {
    const i = r[s], o = e[i];
    if (o) {
      const c = t[i], l = c === void 0 || o(c, i, t);
      if (l !== !0)
        throw new O("option " + i + " must be " + l, O.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (n !== !0)
      throw new O("Unknown option " + i, O.ERR_BAD_OPTION);
  }
}
var jn = {
  assertOptions: sa,
  validators: ur
};
const je = jn.validators;
class Qt {
  constructor(e) {
    this.defaults = e, this.interceptors = {
      request: new Pr(),
      response: new Pr()
    };
  }
  async request(e, n) {
    try {
      return await this._request(e, n);
    } catch (r) {
      if (r instanceof Error) {
        let s;
        Error.captureStackTrace ? Error.captureStackTrace(s = {}) : s = new Error();
        const i = s.stack ? s.stack.replace(/^.+\n/, "") : "";
        try {
          r.stack ? i && !String(r.stack).endsWith(i.replace(/^.+\n.+\n/, "")) && (r.stack += `
` + i) : r.stack = i;
        } catch {
        }
      }
      throw r;
    }
  }
  _request(e, n) {
    typeof e == "string" ? (n = n || {}, n.url = e) : n = e || {}, n = Ge(this.defaults, n);
    const { transitional: r, paramsSerializer: s, headers: i } = n;
    r !== void 0 && jn.assertOptions(r, {
      silentJSONParsing: je.transitional(je.boolean),
      forcedJSONParsing: je.transitional(je.boolean),
      clarifyTimeoutError: je.transitional(je.boolean)
    }, !1), s != null && (d.isFunction(s) ? n.paramsSerializer = {
      serialize: s
    } : jn.assertOptions(s, {
      encode: je.function,
      serialize: je.function
    }, !0)), n.method = (n.method || this.defaults.method || "get").toLowerCase();
    let o = i && d.merge(
      i.common,
      i[n.method]
    );
    i && d.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (p) => {
        delete i[p];
      }
    ), n.headers = Se.concat(o, i);
    const c = [];
    let l = !0;
    this.interceptors.request.forEach(function(g) {
      typeof g.runWhen == "function" && g.runWhen(n) === !1 || (l = l && g.synchronous, c.unshift(g.fulfilled, g.rejected));
    });
    const a = [];
    this.interceptors.response.forEach(function(g) {
      a.push(g.fulfilled, g.rejected);
    });
    let f, h = 0, y;
    if (!l) {
      const p = [qr.bind(this), void 0];
      for (p.unshift.apply(p, c), p.push.apply(p, a), y = p.length, f = Promise.resolve(n); h < y; )
        f = f.then(p[h++], p[h++]);
      return f;
    }
    y = c.length;
    let m = n;
    for (h = 0; h < y; ) {
      const p = c[h++], g = c[h++];
      try {
        m = p(m);
      } catch (w) {
        g.call(this, w);
        break;
      }
    }
    try {
      f = qr.call(this, m);
    } catch (p) {
      return Promise.reject(p);
    }
    for (h = 0, y = a.length; h < y; )
      f = f.then(a[h++], a[h++]);
    return f;
  }
  getUri(e) {
    e = Ge(this.defaults, e);
    const n = Cs(e.baseURL, e.url);
    return Rs(n, e.params, e.paramsSerializer);
  }
}
d.forEach(["delete", "get", "head", "options"], function(e) {
  Qt.prototype[e] = function(n, r) {
    return this.request(Ge(r || {}, {
      method: e,
      url: n,
      data: (r || {}).data
    }));
  };
});
d.forEach(["post", "put", "patch"], function(e) {
  function n(r) {
    return function(i, o, c) {
      return this.request(Ge(c || {}, {
        method: e,
        headers: r ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: i,
        data: o
      }));
    };
  }
  Qt.prototype[e] = n(), Qt.prototype[e + "Form"] = n(!0);
});
var Wt = Qt;
class lr {
  constructor(e) {
    if (typeof e != "function")
      throw new TypeError("executor must be a function.");
    let n;
    this.promise = new Promise(function(i) {
      n = i;
    });
    const r = this;
    this.promise.then((s) => {
      if (!r._listeners)
        return;
      let i = r._listeners.length;
      for (; i-- > 0; )
        r._listeners[i](s);
      r._listeners = null;
    }), this.promise.then = (s) => {
      let i;
      const o = new Promise((c) => {
        r.subscribe(c), i = c;
      }).then(s);
      return o.cancel = function() {
        r.unsubscribe(i);
      }, o;
    }, e(function(i, o, c) {
      r.reason || (r.reason = new ut(i, o, c), n(r.reason));
    });
  }
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  subscribe(e) {
    if (this.reason) {
      e(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(e) : this._listeners = [e];
  }
  unsubscribe(e) {
    if (!this._listeners)
      return;
    const n = this._listeners.indexOf(e);
    n !== -1 && this._listeners.splice(n, 1);
  }
  static source() {
    let e;
    return {
      token: new lr(function(s) {
        e = s;
      }),
      cancel: e
    };
  }
}
var ia = lr;
function oa(t) {
  return function(n) {
    return t.apply(null, n);
  };
}
function aa(t) {
  return d.isObject(t) && t.isAxiosError === !0;
}
const qn = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(qn).forEach(([t, e]) => {
  qn[e] = t;
});
var ca = qn;
function Ns(t) {
  const e = new Wt(t), n = fs(Wt.prototype.request, e);
  return d.extend(n, Wt.prototype, e, { allOwnKeys: !0 }), d.extend(n, e, null, { allOwnKeys: !0 }), n.create = function(s) {
    return Ns(Ge(t, s));
  }, n;
}
const te = Ns(cr);
te.Axios = Wt;
te.CanceledError = ut;
te.CancelToken = ia;
te.isCancel = Os;
te.VERSION = ks;
te.toFormData = sn;
te.AxiosError = O;
te.Cancel = te.CanceledError;
te.all = function(e) {
  return Promise.all(e);
};
te.spread = oa;
te.isAxiosError = aa;
te.mergeConfig = Ge;
te.AxiosHeaders = Se;
te.formToJSON = (t) => Ts(d.isHTMLForm(t) ? new FormData(t) : t);
te.getAdapter = Ps.getAdapter;
te.HttpStatusCode = ca;
te.default = te;
var ua = te, Zt = F && F.__assign || function() {
  return Zt = Object.assign || function(t) {
    for (var e, n = 1, r = arguments.length; n < r; n++) {
      e = arguments[n];
      for (var s in e)
        Object.prototype.hasOwnProperty.call(e, s) && (t[s] = e[s]);
    }
    return t;
  }, Zt.apply(this, arguments);
};
Object.defineProperty(Ke, "__esModule", { value: !0 });
Ke.getRequestHeaders = Ke.getAxiosClient = void 0;
var la = ua;
function fa(t, e, n, r, s) {
  return la.default.create({
    baseURL: t,
    headers: Fs(e, r, n, t, s),
    withCredentials: !0
  });
}
Ke.getAxiosClient = fa;
function Fs(t, e, n, r, s) {
  t === void 0 && (t = !1);
  var i = {
    Accept: "application/json",
    "Content-Type": "application/json; charset=utf-8"
  };
  return t && e && n && (i.Authorization = "".concat(e, " ").concat(n())), typeof window < "u" && typeof document < "u" && (window.location && (r && r !== window.location.origin || (i["X-Frappe-Site-Name"] = window.location.hostname)), window.csrf_token && window.csrf_token !== "{{ csrf_token }}" && (i["X-Frappe-CSRF-Token"] = window.csrf_token)), Zt(Zt({}, i), s != null ? s : {});
}
Ke.getRequestHeaders = Fs;
var it = F && F.__assign || function() {
  return it = Object.assign || function(t) {
    for (var e, n = 1, r = arguments.length; n < r; n++) {
      e = arguments[n];
      for (var s in e)
        Object.prototype.hasOwnProperty.call(e, s) && (t[s] = e[s]);
    }
    return t;
  }, it.apply(this, arguments);
}, ha = F && F.__awaiter || function(t, e, n, r) {
  function s(i) {
    return i instanceof n ? i : new n(function(o) {
      o(i);
    });
  }
  return new (n || (n = Promise))(function(i, o) {
    function c(f) {
      try {
        a(r.next(f));
      } catch (h) {
        o(h);
      }
    }
    function l(f) {
      try {
        a(r.throw(f));
      } catch (h) {
        o(h);
      }
    }
    function a(f) {
      f.done ? i(f.value) : s(f.value).then(c, l);
    }
    a((r = r.apply(t, e || [])).next());
  });
}, da = F && F.__generator || function(t, e) {
  var n = { label: 0, sent: function() {
    if (i[0] & 1)
      throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, s, i, o;
  return o = { next: c(0), throw: c(1), return: c(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function c(a) {
    return function(f) {
      return l([a, f]);
    };
  }
  function l(a) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, a[0] && (n = 0)), n; )
      try {
        if (r = 1, s && (i = a[0] & 2 ? s.return : a[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, a[1])).done)
          return i;
        switch (s = 0, i && (a = [a[0] & 2, i.value]), a[0]) {
          case 0:
          case 1:
            i = a;
            break;
          case 4:
            return n.label++, { value: a[1], done: !1 };
          case 5:
            n.label++, s = a[1], a = [0];
            continue;
          case 7:
            a = n.ops.pop(), n.trys.pop();
            continue;
          default:
            if (i = n.trys, !(i = i.length > 0 && i[i.length - 1]) && (a[0] === 6 || a[0] === 2)) {
              n = 0;
              continue;
            }
            if (a[0] === 3 && (!i || a[1] > i[0] && a[1] < i[3])) {
              n.label = a[1];
              break;
            }
            if (a[0] === 6 && n.label < i[1]) {
              n.label = i[1], i = a;
              break;
            }
            if (i && n.label < i[2]) {
              n.label = i[2], n.ops.push(a);
              break;
            }
            i[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        a = e.call(t, n);
      } catch (f) {
        a = [6, f], s = 0;
      } finally {
        r = i = 0;
      }
    if (a[0] & 5)
      throw a[1];
    return { value: a[0] ? a[1] : void 0, done: !0 };
  }
};
Object.defineProperty(Ot, "__esModule", { value: !0 });
Ot.FrappeFileUpload = void 0;
var pa = Ke, ma = function() {
  function t(e, n, r, s, i, o) {
    this.appURL = e, this.axios = n, this.useToken = r != null ? r : !1, this.token = s, this.tokenType = i, this.customHeaders = o;
  }
  return t.prototype.uploadFile = function(e, n, r, s) {
    return s === void 0 && (s = "upload_file"), ha(this, void 0, void 0, function() {
      var i, o, c, l, a, f, h, y;
      return da(this, function(m) {
        return i = new FormData(), e && i.append("file", e, e.name), o = n.isPrivate, c = n.folder, l = n.file_url, a = n.doctype, f = n.docname, h = n.fieldname, y = n.otherData, o && i.append("is_private", "1"), c && i.append("folder", c), l && i.append("file_url", l), a && f && (i.append("doctype", a), i.append("docname", f), h && i.append("fieldname", h)), y && Object.keys(y).forEach(function(p) {
          var g = y[p];
          i.append(p, g);
        }), [2, this.axios.post("/api/method/".concat(s), i, {
          onUploadProgress: function(p) {
            r && r(p.loaded, p.total, p);
          },
          headers: it(it({}, (0, pa.getRequestHeaders)(this.useToken, this.tokenType, this.token, this.appURL, this.customHeaders)), { "Content-Type": "multipart/form-data" })
        }).catch(function(p) {
          var g, w;
          throw it(it({}, p.response.data), { httpStatus: p.response.status, httpStatusText: p.response.statusText, message: (g = p.response.data.message) !== null && g !== void 0 ? g : "There was an error while uploading the file.", exception: (w = p.response.data.exception) !== null && w !== void 0 ? w : "" });
        })];
      });
    });
  }, t;
}();
Ot.FrappeFileUpload = ma;
var $r;
function ya() {
  if ($r)
    return pt;
  $r = 1, Object.defineProperty(pt, "__esModule", { value: !0 }), pt.FrappeApp = void 0;
  var t = Bs(), e = St, n = Tt, r = Ot, s = Ke, i = function() {
    function o(c, l, a, f) {
      var h, y;
      this.url = c, this.name = a != null ? a : "FrappeApp", this.useToken = (h = l == null ? void 0 : l.useToken) !== null && h !== void 0 ? h : !1, this.token = l == null ? void 0 : l.token, this.tokenType = (y = l == null ? void 0 : l.type) !== null && y !== void 0 ? y : "Bearer", this.customHeaders = f, this.axios = (0, s.getAxiosClient)(this.url, this.useToken, this.token, this.tokenType, this.customHeaders);
    }
    return o.prototype.auth = function() {
      return new t.FrappeAuth(this.url, this.axios, this.useToken, this.token, this.tokenType);
    }, o.prototype.db = function() {
      return new n.FrappeDB(this.url, this.axios, this.useToken, this.token, this.tokenType);
    }, o.prototype.file = function() {
      return new r.FrappeFileUpload(this.url, this.axios, this.useToken, this.token, this.tokenType, this.customHeaders);
    }, o.prototype.call = function() {
      return new e.FrappeCall(this.url, this.axios, this.useToken, this.token, this.tokenType);
    }, o;
  }();
  return pt.FrappeApp = i, pt;
}
var cn = {}, Ce = F && F.__assign || function() {
  return Ce = Object.assign || function(t) {
    for (var e, n = 1, r = arguments.length; n < r; n++) {
      e = arguments[n];
      for (var s in e)
        Object.prototype.hasOwnProperty.call(e, s) && (t[s] = e[s]);
    }
    return t;
  }, Ce.apply(this, arguments);
}, Nt = F && F.__awaiter || function(t, e, n, r) {
  function s(i) {
    return i instanceof n ? i : new n(function(o) {
      o(i);
    });
  }
  return new (n || (n = Promise))(function(i, o) {
    function c(f) {
      try {
        a(r.next(f));
      } catch (h) {
        o(h);
      }
    }
    function l(f) {
      try {
        a(r.throw(f));
      } catch (h) {
        o(h);
      }
    }
    function a(f) {
      f.done ? i(f.value) : s(f.value).then(c, l);
    }
    a((r = r.apply(t, e || [])).next());
  });
}, Ft = F && F.__generator || function(t, e) {
  var n = { label: 0, sent: function() {
    if (i[0] & 1)
      throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, s, i, o;
  return o = { next: c(0), throw: c(1), return: c(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function c(a) {
    return function(f) {
      return l([a, f]);
    };
  }
  function l(a) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, a[0] && (n = 0)), n; )
      try {
        if (r = 1, s && (i = a[0] & 2 ? s.return : a[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, a[1])).done)
          return i;
        switch (s = 0, i && (a = [a[0] & 2, i.value]), a[0]) {
          case 0:
          case 1:
            i = a;
            break;
          case 4:
            return n.label++, { value: a[1], done: !1 };
          case 5:
            n.label++, s = a[1], a = [0];
            continue;
          case 7:
            a = n.ops.pop(), n.trys.pop();
            continue;
          default:
            if (i = n.trys, !(i = i.length > 0 && i[i.length - 1]) && (a[0] === 6 || a[0] === 2)) {
              n = 0;
              continue;
            }
            if (a[0] === 3 && (!i || a[1] > i[0] && a[1] < i[3])) {
              n.label = a[1];
              break;
            }
            if (a[0] === 6 && n.label < i[1]) {
              n.label = i[1], i = a;
              break;
            }
            if (i && n.label < i[2]) {
              n.label = i[2], n.ops.push(a);
              break;
            }
            i[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        a = e.call(t, n);
      } catch (f) {
        a = [6, f], s = 0;
      } finally {
        r = i = 0;
      }
    if (a[0] & 5)
      throw a[1];
    return { value: a[0] ? a[1] : void 0, done: !0 };
  }
};
Object.defineProperty(cn, "__esModule", { value: !0 });
cn.FrappeAuth = void 0;
var ga = function() {
  function t(e, n, r, s, i) {
    this.appURL = e, this.axios = n, this.useToken = r != null ? r : !1, this.token = s, this.tokenType = i;
  }
  return t.prototype.loginWithUsernamePassword = function(e) {
    return Nt(this, void 0, void 0, function() {
      return Ft(this, function(n) {
        return [2, this.axios.post("/api/method/login", {
          usr: e.username,
          pwd: e.password,
          otp: e.otp,
          tmp_id: e.tmp_id,
          device: e.device
        }).then(function(r) {
          return r.data;
        }).catch(function(r) {
          var s, i;
          throw Ce(Ce({}, r.response.data), { httpStatus: r.response.status, httpStatusText: r.response.statusText, message: (s = r.response.data.message) !== null && s !== void 0 ? s : "There was an error while logging in", exception: (i = r.response.data.exception) !== null && i !== void 0 ? i : "" });
        })];
      });
    });
  }, t.prototype.getLoggedInUser = function() {
    return Nt(this, void 0, void 0, function() {
      return Ft(this, function(e) {
        return [2, this.axios.get("/api/method/frappe.auth.get_logged_user").then(function(n) {
          return n.data.message;
        }).catch(function(n) {
          var r;
          throw Ce(Ce({}, n.response.data), { httpStatus: n.response.status, httpStatusText: n.response.statusText, message: "There was an error while fetching the logged in user", exception: (r = n.response.data.exception) !== null && r !== void 0 ? r : "" });
        })];
      });
    });
  }, t.prototype.logout = function() {
    return Nt(this, void 0, void 0, function() {
      return Ft(this, function(e) {
        return [2, this.axios.post("/api/method/logout", {}).then(function() {
        }).catch(function(n) {
          var r, s;
          throw Ce(Ce({}, n.response.data), { httpStatus: n.response.status, httpStatusText: n.response.statusText, message: (r = n.response.data.message) !== null && r !== void 0 ? r : "There was an error while logging out", exception: (s = n.response.data.exception) !== null && s !== void 0 ? s : "" });
        })];
      });
    });
  }, t.prototype.forgetPassword = function(e) {
    return Nt(this, void 0, void 0, function() {
      return Ft(this, function(n) {
        return [2, this.axios.post("/", {
          cmd: "frappe.core.doctype.user.user.reset_password",
          user: e
        }).then(function() {
        }).catch(function(r) {
          var s, i;
          throw Ce(Ce({}, r.response.data), { httpStatus: r.response.status, httpStatusText: r.response.statusText, message: (s = r.response.data.message) !== null && s !== void 0 ? s : "There was an error sending password reset email.", exception: (i = r.response.data.exception) !== null && i !== void 0 ? i : "" });
        })];
      });
    });
  }, t;
}();
cn.FrappeAuth = ga;
var Mr;
function Bs() {
  return Mr || (Mr = 1, function(t) {
    var e = F && F.__createBinding || (Object.create ? function(r, s, i, o) {
      o === void 0 && (o = i);
      var c = Object.getOwnPropertyDescriptor(s, i);
      (!c || ("get" in c ? !s.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
        return s[i];
      } }), Object.defineProperty(r, o, c);
    } : function(r, s, i, o) {
      o === void 0 && (o = i), r[o] = s[i];
    }), n = F && F.__exportStar || function(r, s) {
      for (var i in r)
        i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, r, i);
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), n(ya(), t), n(cn, t), n(Tt, t), n(Ot, t), n(St, t);
  }(vn)), vn;
}
var va = Bs(), fr = { exports: {} }, Rn = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Hr;
function wa() {
  if (Hr)
    return Rn;
  Hr = 1;
  var t = Xe;
  function e(h, y) {
    return h === y && (h !== 0 || 1 / h === 1 / y) || h !== h && y !== y;
  }
  var n = typeof Object.is == "function" ? Object.is : e, r = t.useState, s = t.useEffect, i = t.useLayoutEffect, o = t.useDebugValue;
  function c(h, y) {
    var m = y(), p = r({ inst: { value: m, getSnapshot: y } }), g = p[0].inst, w = p[1];
    return i(
      function() {
        g.value = m, g.getSnapshot = y, l(g) && w({ inst: g });
      },
      [h, m, y]
    ), s(
      function() {
        return l(g) && w({ inst: g }), h(function() {
          l(g) && w({ inst: g });
        });
      },
      [h]
    ), o(m), m;
  }
  function l(h) {
    var y = h.getSnapshot;
    h = h.value;
    try {
      var m = y();
      return !n(h, m);
    } catch {
      return !0;
    }
  }
  function a(h, y) {
    return y();
  }
  var f = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? a : c;
  return Rn.useSyncExternalStore = t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : f, Rn;
}
var Sn = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Wr;
function ba() {
  return Wr || (Wr = 1, process.env.NODE_ENV !== "production" && function() {
    function t(m, p) {
      return m === p && (m !== 0 || 1 / m === 1 / p) || m !== m && p !== p;
    }
    function e(m, p) {
      f || s.startTransition === void 0 || (f = !0, console.error(
        "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
      ));
      var g = p();
      if (!h) {
        var w = p();
        i(g, w) || (console.error(
          "The result of getSnapshot should be cached to avoid an infinite loop"
        ), h = !0);
      }
      w = o({
        inst: { value: g, getSnapshot: p }
      });
      var b = w[0].inst, E = w[1];
      return l(
        function() {
          b.value = g, b.getSnapshot = p, n(b) && E({ inst: b });
        },
        [m, g, p]
      ), c(
        function() {
          return n(b) && E({ inst: b }), m(function() {
            n(b) && E({ inst: b });
          });
        },
        [m]
      ), a(g), g;
    }
    function n(m) {
      var p = m.getSnapshot;
      m = m.value;
      try {
        var g = p();
        return !i(m, g);
      } catch {
        return !0;
      }
    }
    function r(m, p) {
      return p();
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var s = Xe, i = typeof Object.is == "function" ? Object.is : t, o = s.useState, c = s.useEffect, l = s.useLayoutEffect, a = s.useDebugValue, f = !1, h = !1, y = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? r : e;
    Sn.useSyncExternalStore = s.useSyncExternalStore !== void 0 ? s.useSyncExternalStore : y, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }()), Sn;
}
(function(t) {
  process.env.NODE_ENV === "production" ? t.exports = wa() : t.exports = ba();
})(fr);
var zr = Object.prototype.hasOwnProperty;
function Vn(t, e) {
  var n, r;
  if (t === e)
    return !0;
  if (t && e && (n = t.constructor) === e.constructor) {
    if (n === Date)
      return t.getTime() === e.getTime();
    if (n === RegExp)
      return t.toString() === e.toString();
    if (n === Array) {
      if ((r = t.length) === e.length)
        for (; r-- && Vn(t[r], e[r]); )
          ;
      return r === -1;
    }
    if (!n || typeof t == "object") {
      r = 0;
      for (n in t)
        if (zr.call(t, n) && ++r && !zr.call(e, n) || !(n in e) || !Vn(t[n], e[n]))
          return !1;
      return Object.keys(e).length === r;
    }
  }
  return t !== t && e !== e;
}
const Ee = /* @__PURE__ */ new WeakMap(), $e = () => {
}, se = $e(), en = Object, x = (t) => t === se, ve = (t) => typeof t == "function", Be = (t, e) => ({
  ...t,
  ...e
}), Us = (t) => ve(t.then), Tn = {}, Bt = {}, hr = "undefined", un = typeof window != hr, $n = typeof document != hr, _a = () => un && typeof window.requestAnimationFrame != hr, qe = (t, e) => {
  const n = Ee.get(t);
  return [
    () => !x(e) && t.get(e) || Tn,
    (r) => {
      if (!x(e)) {
        const s = t.get(e);
        e in Bt || (Bt[e] = s), n[5](e, Be(s, r), s || Tn);
      }
    },
    n[6],
    () => !x(e) && e in Bt ? Bt[e] : !x(e) && t.get(e) || Tn
  ];
};
let Mn = !0;
const Ea = () => Mn, [Hn, Wn] = un && window.addEventListener ? [
  window.addEventListener.bind(window),
  window.removeEventListener.bind(window)
] : [
  $e,
  $e
], Ra = () => {
  const t = $n && document.visibilityState;
  return x(t) || t !== "hidden";
}, Sa = (t) => ($n && document.addEventListener("visibilitychange", t), Hn("focus", t), () => {
  $n && document.removeEventListener("visibilitychange", t), Wn("focus", t);
}), Ta = (t) => {
  const e = () => {
    Mn = !0, t();
  }, n = () => {
    Mn = !1;
  };
  return Hn("online", e), Hn("offline", n), () => {
    Wn("online", e), Wn("offline", n);
  };
}, Oa = {
  isOnline: Ea,
  isVisible: Ra
}, xa = {
  initFocus: Sa,
  initReconnect: Ta
}, Jr = !Xe.useId, Rt = !un || "Deno" in globalThis, Ca = (t) => _a() ? window.requestAnimationFrame(t) : setTimeout(t, 1), _t = Rt ? at : Oi, On = typeof navigator < "u" && navigator.connection, Yr = !Rt && On && ([
  "slow-2g",
  "2g"
].includes(On.effectiveType) || On.saveData), Ut = /* @__PURE__ */ new WeakMap(), xn = (t, e) => en.prototype.toString.call(t) === `[object ${e}]`;
let Aa = 0;
const zn = (t) => {
  const e = typeof t, n = xn(t, "Date"), r = xn(t, "RegExp"), s = xn(t, "Object");
  let i, o;
  if (en(t) === t && !n && !r) {
    if (i = Ut.get(t), i)
      return i;
    if (i = ++Aa + "~", Ut.set(t, i), Array.isArray(t)) {
      for (i = "@", o = 0; o < t.length; o++)
        i += zn(t[o]) + ",";
      Ut.set(t, i);
    }
    if (s) {
      i = "#";
      const c = en.keys(t).sort();
      for (; !x(o = c.pop()); )
        x(t[o]) || (i += o + ":" + zn(t[o]) + ",");
      Ut.set(t, i);
    }
  } else
    i = n ? t.toJSON() : e == "symbol" ? t.toString() : e == "string" ? JSON.stringify(t) : "" + t;
  return i;
}, ot = (t) => {
  if (ve(t))
    try {
      t = t();
    } catch {
      t = "";
    }
  const e = t;
  return t = typeof t == "string" ? t : (Array.isArray(t) ? t.length : t) ? zn(t) : "", [
    t,
    e
  ];
};
let Da = 0;
const Jn = () => ++Da, Is = 0, js = 1, qs = 2, La = 3;
var yt = {
  __proto__: null,
  ERROR_REVALIDATE_EVENT: La,
  FOCUS_EVENT: Is,
  MUTATE_EVENT: qs,
  RECONNECT_EVENT: js
};
async function Vs(...t) {
  const [e, n, r, s] = t, i = Be({
    populateCache: !0,
    throwOnError: !0
  }, typeof s == "boolean" ? {
    revalidate: s
  } : s || {});
  let o = i.populateCache;
  const c = i.rollbackOnError;
  let l = i.optimisticData;
  const a = (y) => typeof c == "function" ? c(y) : c !== !1, f = i.throwOnError;
  if (ve(n)) {
    const y = n, m = [], p = e.keys();
    for (const g of p)
      !/^\$(inf|sub)\$/.test(g) && y(e.get(g)._k) && m.push(g);
    return Promise.all(m.map(h));
  }
  return h(n);
  async function h(y) {
    const [m] = ot(y);
    if (!m)
      return;
    const [p, g] = qe(e, m), [w, b, E, S] = Ee.get(e), M = () => {
      const V = w[m];
      return (ve(i.revalidate) ? i.revalidate(p().data, y) : i.revalidate !== !1) && (delete E[m], delete S[m], V && V[0]) ? V[0](qs).then(() => p().data) : p().data;
    };
    if (t.length < 3)
      return M();
    let L = r, k;
    const z = Jn();
    b[m] = [
      z,
      0
    ];
    const T = !x(l), W = p(), B = W.data, ie = W._c, fe = x(ie) ? B : ie;
    if (T && (l = ve(l) ? l(fe, B) : l, g({
      data: l,
      _c: fe
    })), ve(L))
      try {
        L = L(fe);
      } catch (V) {
        k = V;
      }
    if (L && Us(L))
      if (L = await L.catch((V) => {
        k = V;
      }), z !== b[m][0]) {
        if (k)
          throw k;
        return L;
      } else
        k && T && a(k) && (o = !0, g({
          data: fe,
          _c: se
        }));
    if (o && !k)
      if (ve(o)) {
        const V = o(L, fe);
        g({
          data: V,
          error: se,
          _c: se
        });
      } else
        g({
          data: L,
          error: se,
          _c: se
        });
    if (b[m][1] = Jn(), Promise.resolve(M()).then(() => {
      g({
        _c: se
      });
    }), k) {
      if (f)
        throw k;
      return;
    }
    return L;
  }
}
const Kr = (t, e) => {
  for (const n in t)
    t[n][0] && t[n][0](e);
}, $s = (t, e) => {
  if (!Ee.has(t)) {
    const n = Be(xa, e), r = {}, s = Vs.bind(se, t);
    let i = $e;
    const o = {}, c = (f, h) => {
      const y = o[f] || [];
      return o[f] = y, y.push(h), () => y.splice(y.indexOf(h), 1);
    }, l = (f, h, y) => {
      t.set(f, h);
      const m = o[f];
      if (m)
        for (const p of m)
          p(h, y);
    }, a = () => {
      if (!Ee.has(t) && (Ee.set(t, [
        r,
        {},
        {},
        {},
        s,
        l,
        c
      ]), !Rt)) {
        const f = n.initFocus(setTimeout.bind(se, Kr.bind(se, r, Is))), h = n.initReconnect(setTimeout.bind(se, Kr.bind(se, r, js)));
        i = () => {
          f && f(), h && h(), Ee.delete(t);
        };
      }
    };
    return a(), [
      t,
      s,
      a,
      i
    ];
  }
  return [
    t,
    Ee.get(t)[4]
  ];
}, Pa = (t, e, n, r, s) => {
  const i = n.errorRetryCount, o = s.retryCount, c = ~~((Math.random() + 0.5) * (1 << (o < 8 ? o : 8))) * n.errorRetryInterval;
  !x(i) && o > i || setTimeout(r, c, s);
}, ka = Vn, [Ct, Na] = $s(/* @__PURE__ */ new Map()), Ms = Be(
  {
    onLoadingSlow: $e,
    onSuccess: $e,
    onError: $e,
    onErrorRetry: Pa,
    onDiscarded: $e,
    revalidateOnFocus: !0,
    revalidateOnReconnect: !0,
    revalidateIfStale: !0,
    shouldRetryOnError: !0,
    errorRetryInterval: Yr ? 1e4 : 5e3,
    focusThrottleInterval: 5 * 1e3,
    dedupingInterval: 2 * 1e3,
    loadingTimeout: Yr ? 5e3 : 3e3,
    compare: ka,
    isPaused: () => !1,
    cache: Ct,
    mutate: Na,
    fallback: {}
  },
  Oa
), Hs = (t, e) => {
  const n = Be(t, e);
  if (e) {
    const { use: r, fallback: s } = t, { use: i, fallback: o } = e;
    r && i && (n.use = r.concat(i)), s && o && (n.fallback = Be(s, o));
  }
  return n;
}, Yn = ls({}), Fa = (t) => {
  const { value: e } = t, n = Y(Yn), r = ve(e), s = Kt(() => r ? e(n) : e, [
    r,
    n,
    e
  ]), i = Kt(() => r ? s : Hs(n, s), [
    r,
    n,
    s
  ]), o = s && s.provider, c = Ae(se);
  o && !c.current && (c.current = $s(o(i.cache || Ct), s));
  const l = c.current;
  return l && (i.cache = l[0], i.mutate = l[1]), _t(() => {
    if (l)
      return l[2] && l[2](), l[3];
  }, []), xi(Yn.Provider, Be(t, {
    value: i
  }));
}, Ws = "$inf$", zs = un && window.__SWR_DEVTOOLS_USE__, Ba = zs ? window.__SWR_DEVTOOLS_USE__ : [], Ua = () => {
  zs && (window.__SWR_DEVTOOLS_REACT__ = Xe);
}, Js = (t) => ve(t[1]) ? [
  t[0],
  t[1],
  t[2] || {}
] : [
  t[0],
  null,
  (t[1] === null ? t[2] : t[1]) || {}
], Ia = () => Be(Ms, Y(Yn)), ln = (t, e) => {
  const [n, r] = ot(t), [, , , s] = Ee.get(Ct);
  if (s[n])
    return s[n];
  const i = e(r);
  return s[n] = i, i;
}, ja = (t) => (e, n, r) => t(e, n && ((...i) => {
  const [o] = ot(e), [, , , c] = Ee.get(Ct);
  if (o.startsWith(Ws))
    return n(...i);
  const l = c[o];
  return x(l) ? n(...i) : (delete c[o], l);
}), r), qa = Ba.concat(ja), Va = (t) => function(...n) {
  const r = Ia(), [s, i, o] = Js(n), c = Hs(r, o);
  let l = t;
  const { use: a } = c, f = (a || []).concat(qa);
  for (let h = f.length; h--; )
    l = f[h](l);
  return l(s, i || c.fetcher || null, c);
}, $a = (t, e, n) => {
  const r = e[t] || (e[t] = []);
  return r.push(n), () => {
    const s = r.indexOf(n);
    s >= 0 && (r[s] = r[r.length - 1], r.pop());
  };
}, Ma = (t, e) => (...n) => {
  const [r, s, i] = Js(n), o = (i.use || []).concat(e);
  return t(r, s, {
    ...i,
    use: o
  });
};
Ua();
const Cn = Xe.use || ((t) => {
  switch (t.status) {
    case "pending":
      throw t;
    case "fulfilled":
      return t.value;
    case "rejected":
      throw t.reason;
    default:
      throw t.status = "pending", t.then((e) => {
        t.status = "fulfilled", t.value = e;
      }, (e) => {
        t.status = "rejected", t.reason = e;
      }), t;
  }
}), An = {
  dedupe: !0
}, Ha = (t, e, n) => {
  const { cache: r, compare: s, suspense: i, fallbackData: o, revalidateOnMount: c, revalidateIfStale: l, refreshInterval: a, refreshWhenHidden: f, refreshWhenOffline: h, keepPreviousData: y } = n, [m, p, g, w] = Ee.get(r), [b, E] = ot(t), S = Ae(!1), M = Ae(!1), L = Ae(b), k = Ae(e), z = Ae(n), T = () => z.current, W = () => T().isVisible() && T().isOnline(), [B, ie, fe, V] = qe(r, b), H = Ae({}).current, ae = x(o) ? x(n.fallback) ? se : n.fallback[b] : o, Oe = (U, j) => {
    for (const oe in H) {
      const $ = oe;
      if ($ === "data") {
        if (!s(U[$], j[$]) && (!x(U[$]) || !s(He, j[$])))
          return !1;
      } else if (j[$] !== U[$])
        return !1;
    }
    return !0;
  }, K = Kt(() => {
    const U = (() => !b || !e ? !1 : x(c) ? T().isPaused() || i ? !1 : l !== !1 : c)(), j = (X) => {
      const be = Be(X);
      return delete be._k, U ? {
        isValidating: !0,
        isLoading: !0,
        ...be
      } : be;
    }, oe = B(), $ = V(), ue = j(oe), Ne = oe === $ ? ue : j($);
    let G = ue;
    return [
      () => {
        const X = j(B());
        return Oe(X, G) ? (G.data = X.data, G.isLoading = X.isLoading, G.isValidating = X.isValidating, G.error = X.error, G) : (G = X, X);
      },
      () => Ne
    ];
  }, [
    r,
    b
  ]), ce = fr.exports.useSyncExternalStore(P(
    (U) => fe(b, (j, oe) => {
      Oe(oe, j) || U();
    }),
    [
      r,
      b
    ]
  ), K[0], K[1]), Pe = !S.current, Qe = m[b] && m[b].length > 0, we = ce.data, re = x(we) ? ae && Us(ae) ? Cn(ae) : ae : we, ke = ce.error, Me = Ae(re), He = y ? x(we) ? Me.current : we : re, Ue = (() => Qe && !x(ke) ? !1 : Pe && !x(c) ? c : T().isPaused() ? !1 : i ? x(re) ? !1 : l : x(re) || l)(), Ze = !!(b && e && Pe && Ue), et = x(ce.isValidating) ? Ze : ce.isValidating, ht = x(ce.isLoading) ? Ze : ce.isLoading, xe = P(
    async (U) => {
      const j = k.current;
      if (!b || !j || M.current || T().isPaused())
        return !1;
      let oe, $, ue = !0;
      const Ne = U || {}, G = !g[b] || !Ne.dedupe, X = () => Jr ? !M.current && b === L.current && S.current : b === L.current, be = {
        isValidating: !1,
        isLoading: !1
      }, Dt = () => {
        ie(be);
      }, tt = () => {
        const he = g[b];
        he && he[1] === $ && delete g[b];
      }, Lt = {
        isValidating: !0
      };
      x(B().data) && (Lt.isLoading = !0);
      try {
        if (G && (ie(Lt), n.loadingTimeout && x(B().data) && setTimeout(() => {
          ue && X() && T().onLoadingSlow(b, n);
        }, n.loadingTimeout), g[b] = [
          j(E),
          Jn()
        ]), [oe, $] = g[b], oe = await oe, G && setTimeout(tt, n.dedupingInterval), !g[b] || g[b][1] !== $)
          return G && X() && T().onDiscarded(b), !1;
        be.error = se;
        const he = p[b];
        if (!x(he) && ($ <= he[0] || $ <= he[1] || he[1] === 0))
          return Dt(), G && X() && T().onDiscarded(b), !1;
        const pe = B().data;
        be.data = s(pe, oe) ? pe : oe, G && X() && T().onSuccess(oe, b, n);
      } catch (he) {
        tt();
        const pe = T(), { shouldRetryOnError: nt } = pe;
        pe.isPaused() || (be.error = he, G && X() && (pe.onError(he, b, pe), (nt === !0 || ve(nt) && nt(he)) && (!T().revalidateOnFocus || !T().revalidateOnReconnect || W()) && pe.onErrorRetry(he, b, pe, (We) => {
          const dt = m[b];
          dt && dt[0] && dt[0](yt.ERROR_REVALIDATE_EVENT, We);
        }, {
          retryCount: (Ne.retryCount || 0) + 1,
          dedupe: !0
        })));
      }
      return ue = !1, Dt(), !0;
    },
    [
      b,
      r
    ]
  ), At = P(
    (...U) => Vs(r, L.current, ...U),
    []
  );
  if (_t(() => {
    k.current = e, z.current = n, x(we) || (Me.current = we);
  }), _t(() => {
    if (!b)
      return;
    const U = xe.bind(se, An);
    let j = 0;
    const $ = $a(b, m, (ue, Ne = {}) => {
      if (ue == yt.FOCUS_EVENT) {
        const G = Date.now();
        T().revalidateOnFocus && G > j && W() && (j = G + T().focusThrottleInterval, U());
      } else if (ue == yt.RECONNECT_EVENT)
        T().revalidateOnReconnect && W() && U();
      else {
        if (ue == yt.MUTATE_EVENT)
          return xe();
        if (ue == yt.ERROR_REVALIDATE_EVENT)
          return xe(Ne);
      }
    });
    return M.current = !1, L.current = b, S.current = !0, ie({
      _k: E
    }), Ue && (x(re) || Rt ? U() : Ca(U)), () => {
      M.current = !0, $();
    };
  }, [
    b
  ]), _t(() => {
    let U;
    function j() {
      const $ = ve(a) ? a(B().data) : a;
      $ && U !== -1 && (U = setTimeout(oe, $));
    }
    function oe() {
      !B().error && (f || T().isVisible()) && (h || T().isOnline()) ? xe(An).then(j) : j();
    }
    return j(), () => {
      U && (clearTimeout(U), U = -1);
    };
  }, [
    a,
    f,
    h,
    b
  ]), Ci(He), i && x(re) && b) {
    if (!Jr && Rt)
      throw new Error("Fallback data is required when using Suspense in SSR.");
    k.current = e, z.current = n, M.current = !1;
    const U = w[b];
    if (!x(U)) {
      const j = At(U);
      Cn(j);
    }
    if (x(ke)) {
      const j = xe(An);
      x(He) || (j.status = "fulfilled", j.value = !0), Cn(j);
    } else
      throw ke;
  }
  return {
    mutate: At,
    get data() {
      return H.data = !0, He;
    },
    get error() {
      return H.error = !0, ke;
    },
    get isValidating() {
      return H.isValidating = !0, et;
    },
    get isLoading() {
      return H.isLoading = !0, ht;
    }
  };
}, Wa = en.defineProperty(Fa, "defaultValue", {
  value: Ms
}), lt = Va(Ha), za = () => {
}, Ja = za(), Kn = Object, Gr = (t) => t === Ja, Ya = (t) => typeof t == "function", It = /* @__PURE__ */ new WeakMap(), Dn = (t, e) => Kn.prototype.toString.call(t) === `[object ${e}]`;
let Ka = 0;
const Gn = (t) => {
  const e = typeof t, n = Dn(t, "Date"), r = Dn(t, "RegExp"), s = Dn(t, "Object");
  let i, o;
  if (Kn(t) === t && !n && !r) {
    if (i = It.get(t), i)
      return i;
    if (i = ++Ka + "~", It.set(t, i), Array.isArray(t)) {
      for (i = "@", o = 0; o < t.length; o++)
        i += Gn(t[o]) + ",";
      It.set(t, i);
    }
    if (s) {
      i = "#";
      const c = Kn.keys(t).sort();
      for (; !Gr(o = c.pop()); )
        Gr(t[o]) || (i += o + ":" + Gn(t[o]) + ",");
      It.set(t, i);
    }
  } else
    i = n ? t.toJSON() : e == "symbol" ? t.toString() : e == "string" ? JSON.stringify(t) : "" + t;
  return i;
}, Ga = (t) => {
  if (Ya(t))
    try {
      t = t();
    } catch {
      t = "";
    }
  const e = t;
  return t = typeof t == "string" ? t : (Array.isArray(t) ? t.length : t) ? Gn(t) : "", [
    t,
    e
  ];
}, Xa = (t) => Ga(t ? t(0, null) : null)[0], Ln = Promise.resolve(), Qa = (t) => (e, n, r) => {
  const s = Ae(!1), { cache: i, initialSize: o = 1, revalidateAll: c = !1, persistSize: l = !1, revalidateFirstPage: a = !0, revalidateOnMount: f = !1, parallel: h = !1 } = r, [, , , y] = Ee.get(Ct);
  let m;
  try {
    m = Xa(e), m && (m = Ws + m);
  } catch {
  }
  const [p, g, w] = qe(i, m), b = P(() => x(p()._l) ? o : p()._l, [
    i,
    m,
    o
  ]);
  fr.exports.useSyncExternalStore(P(
    (T) => m ? w(m, () => {
      T();
    }) : () => {
    },
    [
      i,
      m
    ]
  ), b, b);
  const E = P(() => {
    const T = p()._l;
    return x(T) ? o : T;
  }, [
    m,
    o
  ]), S = Ae(E());
  _t(() => {
    if (!s.current) {
      s.current = !0;
      return;
    }
    m && g({
      _l: l ? S.current : E()
    });
  }, [
    m,
    i
  ]);
  const M = f && !s.current, L = t(m, async (T) => {
    const W = p()._i, B = p()._r;
    g({
      _r: se
    });
    const ie = [], fe = E(), [V] = qe(i, T), H = V().data, ae = [];
    let Oe = null;
    for (let K = 0; K < fe; ++K) {
      const [ce, Pe] = ot(e(K, h ? null : Oe));
      if (!ce)
        break;
      const [Qe, we] = qe(i, ce);
      let re = Qe().data;
      const ke = c || W || x(re) || a && !K && !x(H) || M || H && !x(H[K]) && !r.compare(H[K], re);
      if (n && (typeof B == "function" ? B(re, Pe) : ke)) {
        const Me = async () => {
          if (!(ce in y))
            re = await n(Pe);
          else {
            const Ue = y[ce];
            delete y[ce], re = await Ue;
          }
          we({
            data: re,
            _k: Pe
          }), ie[K] = re;
        };
        h ? ae.push(Me) : await Me();
      } else
        ie[K] = re;
      h || (Oe = re);
    }
    return h && await Promise.all(ae.map((K) => K())), g({
      _i: se
    }), ie;
  }, r), k = P(
    function(T, W) {
      const B = typeof W == "boolean" ? {
        revalidate: W
      } : W || {}, ie = B.revalidate !== !1;
      return m ? (ie && (x(T) ? g({
        _i: !0,
        _r: B.revalidate
      }) : g({
        _i: !1,
        _r: B.revalidate
      })), arguments.length ? L.mutate(T, {
        ...B,
        revalidate: ie
      }) : L.mutate()) : Ln;
    },
    [
      m,
      i
    ]
  ), z = P(
    (T) => {
      if (!m)
        return Ln;
      const [, W] = qe(i, m);
      let B;
      if (ve(T) ? B = T(E()) : typeof T == "number" && (B = T), typeof B != "number")
        return Ln;
      W({
        _l: B
      }), S.current = B;
      const ie = [], [fe] = qe(i, m);
      let V = null;
      for (let H = 0; H < B; ++H) {
        const [ae] = ot(e(H, V)), [Oe] = qe(i, ae), K = ae ? Oe().data : se;
        if (x(K))
          return k(fe().data);
        ie.push(K), V = K;
      }
      return k(ie);
    },
    [
      m,
      i,
      k,
      E
    ]
  );
  return {
    size: E(),
    setSize: z,
    mutate: k,
    get data() {
      return L.data;
    },
    get error() {
      return L.error;
    },
    get isValidating() {
      return L.isValidating;
    },
    get isLoading() {
      return L.isLoading;
    }
  };
}, Kc = Ma(lt, Qa), Le = /* @__PURE__ */ Object.create(null);
Le.open = "0";
Le.close = "1";
Le.ping = "2";
Le.pong = "3";
Le.message = "4";
Le.upgrade = "5";
Le.noop = "6";
const zt = /* @__PURE__ */ Object.create(null);
Object.keys(Le).forEach((t) => {
  zt[Le[t]] = t;
});
const Xn = { type: "error", data: "parser error" }, Ys = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]", Ks = typeof ArrayBuffer == "function", Gs = (t) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(t) : t && t.buffer instanceof ArrayBuffer, dr = ({ type: t, data: e }, n, r) => Ys && e instanceof Blob ? n ? r(e) : Xr(e, r) : Ks && (e instanceof ArrayBuffer || Gs(e)) ? n ? r(e) : Xr(new Blob([e]), r) : r(Le[t] + (e || "")), Xr = (t, e) => {
  const n = new FileReader();
  return n.onload = function() {
    const r = n.result.split(",")[1];
    e("b" + (r || ""));
  }, n.readAsDataURL(t);
};
function Qr(t) {
  return t instanceof Uint8Array ? t : t instanceof ArrayBuffer ? new Uint8Array(t) : new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
}
let Pn;
function Za(t, e) {
  if (Ys && t.data instanceof Blob)
    return t.data.arrayBuffer().then(Qr).then(e);
  if (Ks && (t.data instanceof ArrayBuffer || Gs(t.data)))
    return e(Qr(t.data));
  dr(t, !1, (n) => {
    Pn || (Pn = new TextEncoder()), e(Pn.encode(n));
  });
}
const Zr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bt = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (let t = 0; t < Zr.length; t++)
  bt[Zr.charCodeAt(t)] = t;
const ec = (t) => {
  let e = t.length * 0.75, n = t.length, r, s = 0, i, o, c, l;
  t[t.length - 1] === "=" && (e--, t[t.length - 2] === "=" && e--);
  const a = new ArrayBuffer(e), f = new Uint8Array(a);
  for (r = 0; r < n; r += 4)
    i = bt[t.charCodeAt(r)], o = bt[t.charCodeAt(r + 1)], c = bt[t.charCodeAt(r + 2)], l = bt[t.charCodeAt(r + 3)], f[s++] = i << 2 | o >> 4, f[s++] = (o & 15) << 4 | c >> 2, f[s++] = (c & 3) << 6 | l & 63;
  return a;
}, tc = typeof ArrayBuffer == "function", pr = (t, e) => {
  if (typeof t != "string")
    return {
      type: "message",
      data: Xs(t, e)
    };
  const n = t.charAt(0);
  return n === "b" ? {
    type: "message",
    data: nc(t.substring(1), e)
  } : zt[n] ? t.length > 1 ? {
    type: zt[n],
    data: t.substring(1)
  } : {
    type: zt[n]
  } : Xn;
}, nc = (t, e) => {
  if (tc) {
    const n = ec(t);
    return Xs(n, e);
  } else
    return { base64: !0, data: t };
}, Xs = (t, e) => {
  switch (e) {
    case "blob":
      return t instanceof Blob ? t : new Blob([t]);
    case "arraybuffer":
    default:
      return t instanceof ArrayBuffer ? t : t.buffer;
  }
}, Qs = String.fromCharCode(30), rc = (t, e) => {
  const n = t.length, r = new Array(n);
  let s = 0;
  t.forEach((i, o) => {
    dr(i, !1, (c) => {
      r[o] = c, ++s === n && e(r.join(Qs));
    });
  });
}, sc = (t, e) => {
  const n = t.split(Qs), r = [];
  for (let s = 0; s < n.length; s++) {
    const i = pr(n[s], e);
    if (r.push(i), i.type === "error")
      break;
  }
  return r;
};
function ic() {
  return new TransformStream({
    transform(t, e) {
      Za(t, (n) => {
        const r = n.length;
        let s;
        if (r < 126)
          s = new Uint8Array(1), new DataView(s.buffer).setUint8(0, r);
        else if (r < 65536) {
          s = new Uint8Array(3);
          const i = new DataView(s.buffer);
          i.setUint8(0, 126), i.setUint16(1, r);
        } else {
          s = new Uint8Array(9);
          const i = new DataView(s.buffer);
          i.setUint8(0, 127), i.setBigUint64(1, BigInt(r));
        }
        t.data && typeof t.data != "string" && (s[0] |= 128), e.enqueue(s), e.enqueue(n);
      });
    }
  });
}
let kn;
function jt(t) {
  return t.reduce((e, n) => e + n.length, 0);
}
function qt(t, e) {
  if (t[0].length === e)
    return t.shift();
  const n = new Uint8Array(e);
  let r = 0;
  for (let s = 0; s < e; s++)
    n[s] = t[0][r++], r === t[0].length && (t.shift(), r = 0);
  return t.length && r < t[0].length && (t[0] = t[0].slice(r)), n;
}
function oc(t, e) {
  kn || (kn = new TextDecoder());
  const n = [];
  let r = 0, s = -1, i = !1;
  return new TransformStream({
    transform(o, c) {
      for (n.push(o); ; ) {
        if (r === 0) {
          if (jt(n) < 1)
            break;
          const l = qt(n, 1);
          i = (l[0] & 128) === 128, s = l[0] & 127, s < 126 ? r = 3 : s === 126 ? r = 1 : r = 2;
        } else if (r === 1) {
          if (jt(n) < 2)
            break;
          const l = qt(n, 2);
          s = new DataView(l.buffer, l.byteOffset, l.length).getUint16(0), r = 3;
        } else if (r === 2) {
          if (jt(n) < 8)
            break;
          const l = qt(n, 8), a = new DataView(l.buffer, l.byteOffset, l.length), f = a.getUint32(0);
          if (f > Math.pow(2, 53 - 32) - 1) {
            c.enqueue(Xn);
            break;
          }
          s = f * Math.pow(2, 32) + a.getUint32(4), r = 3;
        } else {
          if (jt(n) < s)
            break;
          const l = qt(n, s);
          c.enqueue(pr(i ? l : kn.decode(l), e)), r = 0;
        }
        if (s === 0 || s > t) {
          c.enqueue(Xn);
          break;
        }
      }
    }
  });
}
const Zs = 4;
function ee(t) {
  if (t)
    return ac(t);
}
function ac(t) {
  for (var e in ee.prototype)
    t[e] = ee.prototype[e];
  return t;
}
ee.prototype.on = ee.prototype.addEventListener = function(t, e) {
  return this._callbacks = this._callbacks || {}, (this._callbacks["$" + t] = this._callbacks["$" + t] || []).push(e), this;
};
ee.prototype.once = function(t, e) {
  function n() {
    this.off(t, n), e.apply(this, arguments);
  }
  return n.fn = e, this.on(t, n), this;
};
ee.prototype.off = ee.prototype.removeListener = ee.prototype.removeAllListeners = ee.prototype.removeEventListener = function(t, e) {
  if (this._callbacks = this._callbacks || {}, arguments.length == 0)
    return this._callbacks = {}, this;
  var n = this._callbacks["$" + t];
  if (!n)
    return this;
  if (arguments.length == 1)
    return delete this._callbacks["$" + t], this;
  for (var r, s = 0; s < n.length; s++)
    if (r = n[s], r === e || r.fn === e) {
      n.splice(s, 1);
      break;
    }
  return n.length === 0 && delete this._callbacks["$" + t], this;
};
ee.prototype.emit = function(t) {
  this._callbacks = this._callbacks || {};
  for (var e = new Array(arguments.length - 1), n = this._callbacks["$" + t], r = 1; r < arguments.length; r++)
    e[r - 1] = arguments[r];
  if (n) {
    n = n.slice(0);
    for (var r = 0, s = n.length; r < s; ++r)
      n[r].apply(this, e);
  }
  return this;
};
ee.prototype.emitReserved = ee.prototype.emit;
ee.prototype.listeners = function(t) {
  return this._callbacks = this._callbacks || {}, this._callbacks["$" + t] || [];
};
ee.prototype.hasListeners = function(t) {
  return !!this.listeners(t).length;
};
const ge = (() => typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")())();
function ei(t, ...e) {
  return e.reduce((n, r) => (t.hasOwnProperty(r) && (n[r] = t[r]), n), {});
}
const cc = ge.setTimeout, uc = ge.clearTimeout;
function fn(t, e) {
  e.useNativeTimers ? (t.setTimeoutFn = cc.bind(ge), t.clearTimeoutFn = uc.bind(ge)) : (t.setTimeoutFn = ge.setTimeout.bind(ge), t.clearTimeoutFn = ge.clearTimeout.bind(ge));
}
const lc = 1.33;
function fc(t) {
  return typeof t == "string" ? hc(t) : Math.ceil((t.byteLength || t.size) * lc);
}
function hc(t) {
  let e = 0, n = 0;
  for (let r = 0, s = t.length; r < s; r++)
    e = t.charCodeAt(r), e < 128 ? n += 1 : e < 2048 ? n += 2 : e < 55296 || e >= 57344 ? n += 3 : (r++, n += 4);
  return n;
}
function dc(t) {
  let e = "";
  for (let n in t)
    t.hasOwnProperty(n) && (e.length && (e += "&"), e += encodeURIComponent(n) + "=" + encodeURIComponent(t[n]));
  return e;
}
function pc(t) {
  let e = {}, n = t.split("&");
  for (let r = 0, s = n.length; r < s; r++) {
    let i = n[r].split("=");
    e[decodeURIComponent(i[0])] = decodeURIComponent(i[1]);
  }
  return e;
}
class mc extends Error {
  constructor(e, n, r) {
    super(e), this.description = n, this.context = r, this.type = "TransportError";
  }
}
class mr extends ee {
  constructor(e) {
    super(), this.writable = !1, fn(this, e), this.opts = e, this.query = e.query, this.socket = e.socket;
  }
  onError(e, n, r) {
    return super.emitReserved("error", new mc(e, n, r)), this;
  }
  open() {
    return this.readyState = "opening", this.doOpen(), this;
  }
  close() {
    return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(), this.onClose()), this;
  }
  send(e) {
    this.readyState === "open" && this.write(e);
  }
  onOpen() {
    this.readyState = "open", this.writable = !0, super.emitReserved("open");
  }
  onData(e) {
    const n = pr(e, this.socket.binaryType);
    this.onPacket(n);
  }
  onPacket(e) {
    super.emitReserved("packet", e);
  }
  onClose(e) {
    this.readyState = "closed", super.emitReserved("close", e);
  }
  pause(e) {
  }
  createUri(e, n = {}) {
    return e + "://" + this._hostname() + this._port() + this.opts.path + this._query(n);
  }
  _hostname() {
    const e = this.opts.hostname;
    return e.indexOf(":") === -1 ? e : "[" + e + "]";
  }
  _port() {
    return this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80) ? ":" + this.opts.port : "";
  }
  _query(e) {
    const n = dc(e);
    return n.length ? "?" + n : "";
  }
}
const ti = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), Qn = 64, yc = {};
let es = 0, Vt = 0, ts;
function ns(t) {
  let e = "";
  do
    e = ti[t % Qn] + e, t = Math.floor(t / Qn);
  while (t > 0);
  return e;
}
function ni() {
  const t = ns(+new Date());
  return t !== ts ? (es = 0, ts = t) : t + "." + ns(es++);
}
for (; Vt < Qn; Vt++)
  yc[ti[Vt]] = Vt;
let ri = !1;
try {
  ri = typeof XMLHttpRequest < "u" && "withCredentials" in new XMLHttpRequest();
} catch {
}
const gc = ri;
function si(t) {
  const e = t.xdomain;
  try {
    if (typeof XMLHttpRequest < "u" && (!e || gc))
      return new XMLHttpRequest();
  } catch {
  }
  if (!e)
    try {
      return new ge[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch {
    }
}
function vc() {
}
const wc = function() {
  return new si({
    xdomain: !1
  }).responseType != null;
}();
class bc extends mr {
  constructor(e) {
    if (super(e), this.polling = !1, typeof location < "u") {
      const r = location.protocol === "https:";
      let s = location.port;
      s || (s = r ? "443" : "80"), this.xd = typeof location < "u" && e.hostname !== location.hostname || s !== e.port;
    }
    const n = e && e.forceBase64;
    this.supportsBinary = wc && !n, this.opts.withCredentials && (this.cookieJar = void 0);
  }
  get name() {
    return "polling";
  }
  doOpen() {
    this.poll();
  }
  pause(e) {
    this.readyState = "pausing";
    const n = () => {
      this.readyState = "paused", e();
    };
    if (this.polling || !this.writable) {
      let r = 0;
      this.polling && (r++, this.once("pollComplete", function() {
        --r || n();
      })), this.writable || (r++, this.once("drain", function() {
        --r || n();
      }));
    } else
      n();
  }
  poll() {
    this.polling = !0, this.doPoll(), this.emitReserved("poll");
  }
  onData(e) {
    const n = (r) => {
      if (this.readyState === "opening" && r.type === "open" && this.onOpen(), r.type === "close")
        return this.onClose({ description: "transport closed by the server" }), !1;
      this.onPacket(r);
    };
    sc(e, this.socket.binaryType).forEach(n), this.readyState !== "closed" && (this.polling = !1, this.emitReserved("pollComplete"), this.readyState === "open" && this.poll());
  }
  doClose() {
    const e = () => {
      this.write([{ type: "close" }]);
    };
    this.readyState === "open" ? e() : this.once("open", e);
  }
  write(e) {
    this.writable = !1, rc(e, (n) => {
      this.doWrite(n, () => {
        this.writable = !0, this.emitReserved("drain");
      });
    });
  }
  uri() {
    const e = this.opts.secure ? "https" : "http", n = this.query || {};
    return this.opts.timestampRequests !== !1 && (n[this.opts.timestampParam] = ni()), !this.supportsBinary && !n.sid && (n.b64 = 1), this.createUri(e, n);
  }
  request(e = {}) {
    return Object.assign(e, { xd: this.xd, cookieJar: this.cookieJar }, this.opts), new De(this.uri(), e);
  }
  doWrite(e, n) {
    const r = this.request({
      method: "POST",
      data: e
    });
    r.on("success", n), r.on("error", (s, i) => {
      this.onError("xhr post error", s, i);
    });
  }
  doPoll() {
    const e = this.request();
    e.on("data", this.onData.bind(this)), e.on("error", (n, r) => {
      this.onError("xhr poll error", n, r);
    }), this.pollXhr = e;
  }
}
class De extends ee {
  constructor(e, n) {
    super(), fn(this, n), this.opts = n, this.method = n.method || "GET", this.uri = e, this.data = n.data !== void 0 ? n.data : null, this.create();
  }
  create() {
    var e;
    const n = ei(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    n.xdomain = !!this.opts.xd;
    const r = this.xhr = new si(n);
    try {
      r.open(this.method, this.uri, !0);
      try {
        if (this.opts.extraHeaders) {
          r.setDisableHeaderCheck && r.setDisableHeaderCheck(!0);
          for (let s in this.opts.extraHeaders)
            this.opts.extraHeaders.hasOwnProperty(s) && r.setRequestHeader(s, this.opts.extraHeaders[s]);
        }
      } catch {
      }
      if (this.method === "POST")
        try {
          r.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch {
        }
      try {
        r.setRequestHeader("Accept", "*/*");
      } catch {
      }
      (e = this.opts.cookieJar) === null || e === void 0 || e.addCookies(r), "withCredentials" in r && (r.withCredentials = this.opts.withCredentials), this.opts.requestTimeout && (r.timeout = this.opts.requestTimeout), r.onreadystatechange = () => {
        var s;
        r.readyState === 3 && ((s = this.opts.cookieJar) === null || s === void 0 || s.parseCookies(r)), r.readyState === 4 && (r.status === 200 || r.status === 1223 ? this.onLoad() : this.setTimeoutFn(() => {
          this.onError(typeof r.status == "number" ? r.status : 0);
        }, 0));
      }, r.send(this.data);
    } catch (s) {
      this.setTimeoutFn(() => {
        this.onError(s);
      }, 0);
      return;
    }
    typeof document < "u" && (this.index = De.requestsCount++, De.requests[this.index] = this);
  }
  onError(e) {
    this.emitReserved("error", e, this.xhr), this.cleanup(!0);
  }
  cleanup(e) {
    if (!(typeof this.xhr > "u" || this.xhr === null)) {
      if (this.xhr.onreadystatechange = vc, e)
        try {
          this.xhr.abort();
        } catch {
        }
      typeof document < "u" && delete De.requests[this.index], this.xhr = null;
    }
  }
  onLoad() {
    const e = this.xhr.responseText;
    e !== null && (this.emitReserved("data", e), this.emitReserved("success"), this.cleanup());
  }
  abort() {
    this.cleanup();
  }
}
De.requestsCount = 0;
De.requests = {};
if (typeof document < "u") {
  if (typeof attachEvent == "function")
    attachEvent("onunload", rs);
  else if (typeof addEventListener == "function") {
    const t = "onpagehide" in ge ? "pagehide" : "unload";
    addEventListener(t, rs, !1);
  }
}
function rs() {
  for (let t in De.requests)
    De.requests.hasOwnProperty(t) && De.requests[t].abort();
}
const yr = (() => typeof Promise == "function" && typeof Promise.resolve == "function" ? (e) => Promise.resolve().then(e) : (e, n) => n(e, 0))(), $t = ge.WebSocket || ge.MozWebSocket, ss = !0, _c = "arraybuffer", is = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative";
class Ec extends mr {
  constructor(e) {
    super(e), this.supportsBinary = !e.forceBase64;
  }
  get name() {
    return "websocket";
  }
  doOpen() {
    if (!this.check())
      return;
    const e = this.uri(), n = this.opts.protocols, r = is ? {} : ei(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    this.opts.extraHeaders && (r.headers = this.opts.extraHeaders);
    try {
      this.ws = ss && !is ? n ? new $t(e, n) : new $t(e) : new $t(e, n, r);
    } catch (s) {
      return this.emitReserved("error", s);
    }
    this.ws.binaryType = this.socket.binaryType, this.addEventListeners();
  }
  addEventListeners() {
    this.ws.onopen = () => {
      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();
    }, this.ws.onclose = (e) => this.onClose({
      description: "websocket connection closed",
      context: e
    }), this.ws.onmessage = (e) => this.onData(e.data), this.ws.onerror = (e) => this.onError("websocket error", e);
  }
  write(e) {
    this.writable = !1;
    for (let n = 0; n < e.length; n++) {
      const r = e[n], s = n === e.length - 1;
      dr(r, this.supportsBinary, (i) => {
        const o = {};
        try {
          ss && this.ws.send(i);
        } catch {
        }
        s && yr(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    typeof this.ws < "u" && (this.ws.close(), this.ws = null);
  }
  uri() {
    const e = this.opts.secure ? "wss" : "ws", n = this.query || {};
    return this.opts.timestampRequests && (n[this.opts.timestampParam] = ni()), this.supportsBinary || (n.b64 = 1), this.createUri(e, n);
  }
  check() {
    return !!$t;
  }
}
class Rc extends mr {
  get name() {
    return "webtransport";
  }
  doOpen() {
    typeof WebTransport == "function" && (this.transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]), this.transport.closed.then(() => {
      this.onClose();
    }).catch((e) => {
      this.onError("webtransport error", e);
    }), this.transport.ready.then(() => {
      this.transport.createBidirectionalStream().then((e) => {
        const n = oc(Number.MAX_SAFE_INTEGER, this.socket.binaryType), r = e.readable.pipeThrough(n).getReader(), s = ic();
        s.readable.pipeTo(e.writable), this.writer = s.writable.getWriter();
        const i = () => {
          r.read().then(({ done: c, value: l }) => {
            c || (this.onPacket(l), i());
          }).catch((c) => {
          });
        };
        i();
        const o = { type: "open" };
        this.query.sid && (o.data = `{"sid":"${this.query.sid}"}`), this.writer.write(o).then(() => this.onOpen());
      });
    }));
  }
  write(e) {
    this.writable = !1;
    for (let n = 0; n < e.length; n++) {
      const r = e[n], s = n === e.length - 1;
      this.writer.write(r).then(() => {
        s && yr(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    var e;
    (e = this.transport) === null || e === void 0 || e.close();
  }
}
const Sc = {
  websocket: Ec,
  webtransport: Rc,
  polling: bc
}, Tc = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, Oc = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function Zn(t) {
  if (t.length > 2e3)
    throw "URI too long";
  const e = t, n = t.indexOf("["), r = t.indexOf("]");
  n != -1 && r != -1 && (t = t.substring(0, n) + t.substring(n, r).replace(/:/g, ";") + t.substring(r, t.length));
  let s = Tc.exec(t || ""), i = {}, o = 14;
  for (; o--; )
    i[Oc[o]] = s[o] || "";
  return n != -1 && r != -1 && (i.source = e, i.host = i.host.substring(1, i.host.length - 1).replace(/;/g, ":"), i.authority = i.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), i.ipv6uri = !0), i.pathNames = xc(i, i.path), i.queryKey = Cc(i, i.query), i;
}
function xc(t, e) {
  const n = /\/{2,9}/g, r = e.replace(n, "/").split("/");
  return (e.slice(0, 1) == "/" || e.length === 0) && r.splice(0, 1), e.slice(-1) == "/" && r.splice(r.length - 1, 1), r;
}
function Cc(t, e) {
  const n = {};
  return e.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(r, s, i) {
    s && (n[s] = i);
  }), n;
}
class Ve extends ee {
  constructor(e, n = {}) {
    super(), this.binaryType = _c, this.writeBuffer = [], e && typeof e == "object" && (n = e, e = null), e ? (e = Zn(e), n.hostname = e.host, n.secure = e.protocol === "https" || e.protocol === "wss", n.port = e.port, e.query && (n.query = e.query)) : n.host && (n.hostname = Zn(n.host).host), fn(this, n), this.secure = n.secure != null ? n.secure : typeof location < "u" && location.protocol === "https:", n.hostname && !n.port && (n.port = this.secure ? "443" : "80"), this.hostname = n.hostname || (typeof location < "u" ? location.hostname : "localhost"), this.port = n.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"), this.transports = n.transports || [
      "polling",
      "websocket",
      "webtransport"
    ], this.writeBuffer = [], this.prevBufferLen = 0, this.opts = Object.assign({
      path: "/engine.io",
      agent: !1,
      withCredentials: !1,
      upgrade: !0,
      timestampParam: "t",
      rememberUpgrade: !1,
      addTrailingSlash: !0,
      rejectUnauthorized: !0,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: !1
    }, n), this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : ""), typeof this.opts.query == "string" && (this.opts.query = pc(this.opts.query)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingTimeoutTimer = null, typeof addEventListener == "function" && (this.opts.closeOnBeforeunload && (this.beforeunloadEventListener = () => {
      this.transport && (this.transport.removeAllListeners(), this.transport.close());
    }, addEventListener("beforeunload", this.beforeunloadEventListener, !1)), this.hostname !== "localhost" && (this.offlineEventListener = () => {
      this.onClose("transport close", {
        description: "network connection lost"
      });
    }, addEventListener("offline", this.offlineEventListener, !1))), this.open();
  }
  createTransport(e) {
    const n = Object.assign({}, this.opts.query);
    n.EIO = Zs, n.transport = e, this.id && (n.sid = this.id);
    const r = Object.assign({}, this.opts, {
      query: n,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[e]);
    return new Sc[e](r);
  }
  open() {
    let e;
    if (this.opts.rememberUpgrade && Ve.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1)
      e = "websocket";
    else if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    } else
      e = this.transports[0];
    this.readyState = "opening";
    try {
      e = this.createTransport(e);
    } catch {
      this.transports.shift(), this.open();
      return;
    }
    e.open(), this.setTransport(e);
  }
  setTransport(e) {
    this.transport && this.transport.removeAllListeners(), this.transport = e, e.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (n) => this.onClose("transport close", n));
  }
  probe(e) {
    let n = this.createTransport(e), r = !1;
    Ve.priorWebsocketSuccess = !1;
    const s = () => {
      r || (n.send([{ type: "ping", data: "probe" }]), n.once("packet", (h) => {
        if (!r)
          if (h.type === "pong" && h.data === "probe") {
            if (this.upgrading = !0, this.emitReserved("upgrading", n), !n)
              return;
            Ve.priorWebsocketSuccess = n.name === "websocket", this.transport.pause(() => {
              r || this.readyState !== "closed" && (f(), this.setTransport(n), n.send([{ type: "upgrade" }]), this.emitReserved("upgrade", n), n = null, this.upgrading = !1, this.flush());
            });
          } else {
            const y = new Error("probe error");
            y.transport = n.name, this.emitReserved("upgradeError", y);
          }
      }));
    };
    function i() {
      r || (r = !0, f(), n.close(), n = null);
    }
    const o = (h) => {
      const y = new Error("probe error: " + h);
      y.transport = n.name, i(), this.emitReserved("upgradeError", y);
    };
    function c() {
      o("transport closed");
    }
    function l() {
      o("socket closed");
    }
    function a(h) {
      n && h.name !== n.name && i();
    }
    const f = () => {
      n.removeListener("open", s), n.removeListener("error", o), n.removeListener("close", c), this.off("close", l), this.off("upgrading", a);
    };
    n.once("open", s), n.once("error", o), n.once("close", c), this.once("close", l), this.once("upgrading", a), this.upgrades.indexOf("webtransport") !== -1 && e !== "webtransport" ? this.setTimeoutFn(() => {
      r || n.open();
    }, 200) : n.open();
  }
  onOpen() {
    if (this.readyState = "open", Ve.priorWebsocketSuccess = this.transport.name === "websocket", this.emitReserved("open"), this.flush(), this.readyState === "open" && this.opts.upgrade) {
      let e = 0;
      const n = this.upgrades.length;
      for (; e < n; e++)
        this.probe(this.upgrades[e]);
    }
  }
  onPacket(e) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing")
      switch (this.emitReserved("packet", e), this.emitReserved("heartbeat"), this.resetPingTimeout(), e.type) {
        case "open":
          this.onHandshake(JSON.parse(e.data));
          break;
        case "ping":
          this.sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong");
          break;
        case "error":
          const n = new Error("server error");
          n.code = e.data, this.onError(n);
          break;
        case "message":
          this.emitReserved("data", e.data), this.emitReserved("message", e.data);
          break;
      }
  }
  onHandshake(e) {
    this.emitReserved("handshake", e), this.id = e.sid, this.transport.query.sid = e.sid, this.upgrades = this.filterUpgrades(e.upgrades), this.pingInterval = e.pingInterval, this.pingTimeout = e.pingTimeout, this.maxPayload = e.maxPayload, this.onOpen(), this.readyState !== "closed" && this.resetPingTimeout();
  }
  resetPingTimeout() {
    this.clearTimeoutFn(this.pingTimeoutTimer), this.pingTimeoutTimer = this.setTimeoutFn(() => {
      this.onClose("ping timeout");
    }, this.pingInterval + this.pingTimeout), this.opts.autoUnref && this.pingTimeoutTimer.unref();
  }
  onDrain() {
    this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush();
  }
  flush() {
    if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const e = this.getWritablePackets();
      this.transport.send(e), this.prevBufferLen = e.length, this.emitReserved("flush");
    }
  }
  getWritablePackets() {
    if (!(this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1))
      return this.writeBuffer;
    let n = 1;
    for (let r = 0; r < this.writeBuffer.length; r++) {
      const s = this.writeBuffer[r].data;
      if (s && (n += fc(s)), r > 0 && n > this.maxPayload)
        return this.writeBuffer.slice(0, r);
      n += 2;
    }
    return this.writeBuffer;
  }
  write(e, n, r) {
    return this.sendPacket("message", e, n, r), this;
  }
  send(e, n, r) {
    return this.sendPacket("message", e, n, r), this;
  }
  sendPacket(e, n, r, s) {
    if (typeof n == "function" && (s = n, n = void 0), typeof r == "function" && (s = r, r = null), this.readyState === "closing" || this.readyState === "closed")
      return;
    r = r || {}, r.compress = r.compress !== !1;
    const i = {
      type: e,
      data: n,
      options: r
    };
    this.emitReserved("packetCreate", i), this.writeBuffer.push(i), s && this.once("flush", s), this.flush();
  }
  close() {
    const e = () => {
      this.onClose("forced close"), this.transport.close();
    }, n = () => {
      this.off("upgrade", n), this.off("upgradeError", n), e();
    }, r = () => {
      this.once("upgrade", n), this.once("upgradeError", n);
    };
    return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", () => {
      this.upgrading ? r() : e();
    }) : this.upgrading ? r() : e()), this;
  }
  onError(e) {
    Ve.priorWebsocketSuccess = !1, this.emitReserved("error", e), this.onClose("transport error", e);
  }
  onClose(e, n) {
    (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") && (this.clearTimeoutFn(this.pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), typeof removeEventListener == "function" && (removeEventListener("beforeunload", this.beforeunloadEventListener, !1), removeEventListener("offline", this.offlineEventListener, !1)), this.readyState = "closed", this.id = null, this.emitReserved("close", e, n), this.writeBuffer = [], this.prevBufferLen = 0);
  }
  filterUpgrades(e) {
    const n = [];
    let r = 0;
    const s = e.length;
    for (; r < s; r++)
      ~this.transports.indexOf(e[r]) && n.push(e[r]);
    return n;
  }
}
Ve.protocol = Zs;
function Ac(t, e = "", n) {
  let r = t;
  n = n || typeof location < "u" && location, t == null && (t = n.protocol + "//" + n.host), typeof t == "string" && (t.charAt(0) === "/" && (t.charAt(1) === "/" ? t = n.protocol + t : t = n.host + t), /^(https?|wss?):\/\//.test(t) || (typeof n < "u" ? t = n.protocol + "//" + t : t = "https://" + t), r = Zn(t)), r.port || (/^(http|ws)$/.test(r.protocol) ? r.port = "80" : /^(http|ws)s$/.test(r.protocol) && (r.port = "443")), r.path = r.path || "/";
  const i = r.host.indexOf(":") !== -1 ? "[" + r.host + "]" : r.host;
  return r.id = r.protocol + "://" + i + ":" + r.port + e, r.href = r.protocol + "://" + i + (n && n.port === r.port ? "" : ":" + r.port), r;
}
const Dc = typeof ArrayBuffer == "function", Lc = (t) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(t) : t.buffer instanceof ArrayBuffer, ii = Object.prototype.toString, Pc = typeof Blob == "function" || typeof Blob < "u" && ii.call(Blob) === "[object BlobConstructor]", kc = typeof File == "function" || typeof File < "u" && ii.call(File) === "[object FileConstructor]";
function gr(t) {
  return Dc && (t instanceof ArrayBuffer || Lc(t)) || Pc && t instanceof Blob || kc && t instanceof File;
}
function Jt(t, e) {
  if (!t || typeof t != "object")
    return !1;
  if (Array.isArray(t)) {
    for (let n = 0, r = t.length; n < r; n++)
      if (Jt(t[n]))
        return !0;
    return !1;
  }
  if (gr(t))
    return !0;
  if (t.toJSON && typeof t.toJSON == "function" && arguments.length === 1)
    return Jt(t.toJSON(), !0);
  for (const n in t)
    if (Object.prototype.hasOwnProperty.call(t, n) && Jt(t[n]))
      return !0;
  return !1;
}
function Nc(t) {
  const e = [], n = t.data, r = t;
  return r.data = er(n, e), r.attachments = e.length, { packet: r, buffers: e };
}
function er(t, e) {
  if (!t)
    return t;
  if (gr(t)) {
    const n = { _placeholder: !0, num: e.length };
    return e.push(t), n;
  } else if (Array.isArray(t)) {
    const n = new Array(t.length);
    for (let r = 0; r < t.length; r++)
      n[r] = er(t[r], e);
    return n;
  } else if (typeof t == "object" && !(t instanceof Date)) {
    const n = {};
    for (const r in t)
      Object.prototype.hasOwnProperty.call(t, r) && (n[r] = er(t[r], e));
    return n;
  }
  return t;
}
function Fc(t, e) {
  return t.data = tr(t.data, e), delete t.attachments, t;
}
function tr(t, e) {
  if (!t)
    return t;
  if (t && t._placeholder === !0) {
    if (typeof t.num == "number" && t.num >= 0 && t.num < e.length)
      return e[t.num];
    throw new Error("illegal attachments");
  } else if (Array.isArray(t))
    for (let n = 0; n < t.length; n++)
      t[n] = tr(t[n], e);
  else if (typeof t == "object")
    for (const n in t)
      Object.prototype.hasOwnProperty.call(t, n) && (t[n] = tr(t[n], e));
  return t;
}
const Bc = [
  "connect",
  "connect_error",
  "disconnect",
  "disconnecting",
  "newListener",
  "removeListener"
], Uc = 5;
var A;
(function(t) {
  t[t.CONNECT = 0] = "CONNECT", t[t.DISCONNECT = 1] = "DISCONNECT", t[t.EVENT = 2] = "EVENT", t[t.ACK = 3] = "ACK", t[t.CONNECT_ERROR = 4] = "CONNECT_ERROR", t[t.BINARY_EVENT = 5] = "BINARY_EVENT", t[t.BINARY_ACK = 6] = "BINARY_ACK";
})(A || (A = {}));
class Ic {
  constructor(e) {
    this.replacer = e;
  }
  encode(e) {
    return (e.type === A.EVENT || e.type === A.ACK) && Jt(e) ? this.encodeAsBinary({
      type: e.type === A.EVENT ? A.BINARY_EVENT : A.BINARY_ACK,
      nsp: e.nsp,
      data: e.data,
      id: e.id
    }) : [this.encodeAsString(e)];
  }
  encodeAsString(e) {
    let n = "" + e.type;
    return (e.type === A.BINARY_EVENT || e.type === A.BINARY_ACK) && (n += e.attachments + "-"), e.nsp && e.nsp !== "/" && (n += e.nsp + ","), e.id != null && (n += e.id), e.data != null && (n += JSON.stringify(e.data, this.replacer)), n;
  }
  encodeAsBinary(e) {
    const n = Nc(e), r = this.encodeAsString(n.packet), s = n.buffers;
    return s.unshift(r), s;
  }
}
function os(t) {
  return Object.prototype.toString.call(t) === "[object Object]";
}
class vr extends ee {
  constructor(e) {
    super(), this.reviver = e;
  }
  add(e) {
    let n;
    if (typeof e == "string") {
      if (this.reconstructor)
        throw new Error("got plaintext data when reconstructing a packet");
      n = this.decodeString(e);
      const r = n.type === A.BINARY_EVENT;
      r || n.type === A.BINARY_ACK ? (n.type = r ? A.EVENT : A.ACK, this.reconstructor = new jc(n), n.attachments === 0 && super.emitReserved("decoded", n)) : super.emitReserved("decoded", n);
    } else if (gr(e) || e.base64)
      if (this.reconstructor)
        n = this.reconstructor.takeBinaryData(e), n && (this.reconstructor = null, super.emitReserved("decoded", n));
      else
        throw new Error("got binary data when not reconstructing a packet");
    else
      throw new Error("Unknown type: " + e);
  }
  decodeString(e) {
    let n = 0;
    const r = {
      type: Number(e.charAt(0))
    };
    if (A[r.type] === void 0)
      throw new Error("unknown packet type " + r.type);
    if (r.type === A.BINARY_EVENT || r.type === A.BINARY_ACK) {
      const i = n + 1;
      for (; e.charAt(++n) !== "-" && n != e.length; )
        ;
      const o = e.substring(i, n);
      if (o != Number(o) || e.charAt(n) !== "-")
        throw new Error("Illegal attachments");
      r.attachments = Number(o);
    }
    if (e.charAt(n + 1) === "/") {
      const i = n + 1;
      for (; ++n && !(e.charAt(n) === "," || n === e.length); )
        ;
      r.nsp = e.substring(i, n);
    } else
      r.nsp = "/";
    const s = e.charAt(n + 1);
    if (s !== "" && Number(s) == s) {
      const i = n + 1;
      for (; ++n; ) {
        const o = e.charAt(n);
        if (o == null || Number(o) != o) {
          --n;
          break;
        }
        if (n === e.length)
          break;
      }
      r.id = Number(e.substring(i, n + 1));
    }
    if (e.charAt(++n)) {
      const i = this.tryParse(e.substr(n));
      if (vr.isPayloadValid(r.type, i))
        r.data = i;
      else
        throw new Error("invalid payload");
    }
    return r;
  }
  tryParse(e) {
    try {
      return JSON.parse(e, this.reviver);
    } catch {
      return !1;
    }
  }
  static isPayloadValid(e, n) {
    switch (e) {
      case A.CONNECT:
        return os(n);
      case A.DISCONNECT:
        return n === void 0;
      case A.CONNECT_ERROR:
        return typeof n == "string" || os(n);
      case A.EVENT:
      case A.BINARY_EVENT:
        return Array.isArray(n) && (typeof n[0] == "number" || typeof n[0] == "string" && Bc.indexOf(n[0]) === -1);
      case A.ACK:
      case A.BINARY_ACK:
        return Array.isArray(n);
    }
  }
  destroy() {
    this.reconstructor && (this.reconstructor.finishedReconstruction(), this.reconstructor = null);
  }
}
class jc {
  constructor(e) {
    this.packet = e, this.buffers = [], this.reconPack = e;
  }
  takeBinaryData(e) {
    if (this.buffers.push(e), this.buffers.length === this.reconPack.attachments) {
      const n = Fc(this.reconPack, this.buffers);
      return this.finishedReconstruction(), n;
    }
    return null;
  }
  finishedReconstruction() {
    this.reconPack = null, this.buffers = [];
  }
}
const qc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  protocol: Uc,
  get PacketType() {
    return A;
  },
  Encoder: Ic,
  Decoder: vr
}, Symbol.toStringTag, { value: "Module" }));
function _e(t, e, n) {
  return t.on(e, n), function() {
    t.off(e, n);
  };
}
const Vc = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  newListener: 1,
  removeListener: 1
});
class oi extends ee {
  constructor(e, n, r) {
    super(), this.connected = !1, this.recovered = !1, this.receiveBuffer = [], this.sendBuffer = [], this._queue = [], this._queueSeq = 0, this.ids = 0, this.acks = {}, this.flags = {}, this.io = e, this.nsp = n, r && r.auth && (this.auth = r.auth), this._opts = Object.assign({}, r), this.io._autoConnect && this.open();
  }
  get disconnected() {
    return !this.connected;
  }
  subEvents() {
    if (this.subs)
      return;
    const e = this.io;
    this.subs = [
      _e(e, "open", this.onopen.bind(this)),
      _e(e, "packet", this.onpacket.bind(this)),
      _e(e, "error", this.onerror.bind(this)),
      _e(e, "close", this.onclose.bind(this))
    ];
  }
  get active() {
    return !!this.subs;
  }
  connect() {
    return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === "open" && this.onopen(), this);
  }
  open() {
    return this.connect();
  }
  send(...e) {
    return e.unshift("message"), this.emit.apply(this, e), this;
  }
  emit(e, ...n) {
    if (Vc.hasOwnProperty(e))
      throw new Error('"' + e.toString() + '" is a reserved event name');
    if (n.unshift(e), this._opts.retries && !this.flags.fromQueue && !this.flags.volatile)
      return this._addToQueue(n), this;
    const r = {
      type: A.EVENT,
      data: n
    };
    if (r.options = {}, r.options.compress = this.flags.compress !== !1, typeof n[n.length - 1] == "function") {
      const o = this.ids++, c = n.pop();
      this._registerAckCallback(o, c), r.id = o;
    }
    const s = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
    return this.flags.volatile && (!s || !this.connected) || (this.connected ? (this.notifyOutgoingListeners(r), this.packet(r)) : this.sendBuffer.push(r)), this.flags = {}, this;
  }
  _registerAckCallback(e, n) {
    var r;
    const s = (r = this.flags.timeout) !== null && r !== void 0 ? r : this._opts.ackTimeout;
    if (s === void 0) {
      this.acks[e] = n;
      return;
    }
    const i = this.io.setTimeoutFn(() => {
      delete this.acks[e];
      for (let o = 0; o < this.sendBuffer.length; o++)
        this.sendBuffer[o].id === e && this.sendBuffer.splice(o, 1);
      n.call(this, new Error("operation has timed out"));
    }, s);
    this.acks[e] = (...o) => {
      this.io.clearTimeoutFn(i), n.apply(this, [null, ...o]);
    };
  }
  emitWithAck(e, ...n) {
    const r = this.flags.timeout !== void 0 || this._opts.ackTimeout !== void 0;
    return new Promise((s, i) => {
      n.push((o, c) => r ? o ? i(o) : s(c) : s(o)), this.emit(e, ...n);
    });
  }
  _addToQueue(e) {
    let n;
    typeof e[e.length - 1] == "function" && (n = e.pop());
    const r = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: !1,
      args: e,
      flags: Object.assign({ fromQueue: !0 }, this.flags)
    };
    e.push((s, ...i) => r !== this._queue[0] ? void 0 : (s !== null ? r.tryCount > this._opts.retries && (this._queue.shift(), n && n(s)) : (this._queue.shift(), n && n(null, ...i)), r.pending = !1, this._drainQueue())), this._queue.push(r), this._drainQueue();
  }
  _drainQueue(e = !1) {
    if (!this.connected || this._queue.length === 0)
      return;
    const n = this._queue[0];
    n.pending && !e || (n.pending = !0, n.tryCount++, this.flags = n.flags, this.emit.apply(this, n.args));
  }
  packet(e) {
    e.nsp = this.nsp, this.io._packet(e);
  }
  onopen() {
    typeof this.auth == "function" ? this.auth((e) => {
      this._sendConnectPacket(e);
    }) : this._sendConnectPacket(this.auth);
  }
  _sendConnectPacket(e) {
    this.packet({
      type: A.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, e) : e
    });
  }
  onerror(e) {
    this.connected || this.emitReserved("connect_error", e);
  }
  onclose(e, n) {
    this.connected = !1, delete this.id, this.emitReserved("disconnect", e, n);
  }
  onpacket(e) {
    if (e.nsp === this.nsp)
      switch (e.type) {
        case A.CONNECT:
          e.data && e.data.sid ? this.onconnect(e.data.sid, e.data.pid) : this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          break;
        case A.EVENT:
        case A.BINARY_EVENT:
          this.onevent(e);
          break;
        case A.ACK:
        case A.BINARY_ACK:
          this.onack(e);
          break;
        case A.DISCONNECT:
          this.ondisconnect();
          break;
        case A.CONNECT_ERROR:
          this.destroy();
          const r = new Error(e.data.message);
          r.data = e.data.data, this.emitReserved("connect_error", r);
          break;
      }
  }
  onevent(e) {
    const n = e.data || [];
    e.id != null && n.push(this.ack(e.id)), this.connected ? this.emitEvent(n) : this.receiveBuffer.push(Object.freeze(n));
  }
  emitEvent(e) {
    if (this._anyListeners && this._anyListeners.length) {
      const n = this._anyListeners.slice();
      for (const r of n)
        r.apply(this, e);
    }
    super.emit.apply(this, e), this._pid && e.length && typeof e[e.length - 1] == "string" && (this._lastOffset = e[e.length - 1]);
  }
  ack(e) {
    const n = this;
    let r = !1;
    return function(...s) {
      r || (r = !0, n.packet({
        type: A.ACK,
        id: e,
        data: s
      }));
    };
  }
  onack(e) {
    const n = this.acks[e.id];
    typeof n == "function" && (n.apply(this, e.data), delete this.acks[e.id]);
  }
  onconnect(e, n) {
    this.id = e, this.recovered = n && this._pid === n, this._pid = n, this.connected = !0, this.emitBuffered(), this.emitReserved("connect"), this._drainQueue(!0);
  }
  emitBuffered() {
    this.receiveBuffer.forEach((e) => this.emitEvent(e)), this.receiveBuffer = [], this.sendBuffer.forEach((e) => {
      this.notifyOutgoingListeners(e), this.packet(e);
    }), this.sendBuffer = [];
  }
  ondisconnect() {
    this.destroy(), this.onclose("io server disconnect");
  }
  destroy() {
    this.subs && (this.subs.forEach((e) => e()), this.subs = void 0), this.io._destroy(this);
  }
  disconnect() {
    return this.connected && this.packet({ type: A.DISCONNECT }), this.destroy(), this.connected && this.onclose("io client disconnect"), this;
  }
  close() {
    return this.disconnect();
  }
  compress(e) {
    return this.flags.compress = e, this;
  }
  get volatile() {
    return this.flags.volatile = !0, this;
  }
  timeout(e) {
    return this.flags.timeout = e, this;
  }
  onAny(e) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.push(e), this;
  }
  prependAny(e) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(e), this;
  }
  offAny(e) {
    if (!this._anyListeners)
      return this;
    if (e) {
      const n = this._anyListeners;
      for (let r = 0; r < n.length; r++)
        if (e === n[r])
          return n.splice(r, 1), this;
    } else
      this._anyListeners = [];
    return this;
  }
  listenersAny() {
    return this._anyListeners || [];
  }
  onAnyOutgoing(e) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(e), this;
  }
  prependAnyOutgoing(e) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(e), this;
  }
  offAnyOutgoing(e) {
    if (!this._anyOutgoingListeners)
      return this;
    if (e) {
      const n = this._anyOutgoingListeners;
      for (let r = 0; r < n.length; r++)
        if (e === n[r])
          return n.splice(r, 1), this;
    } else
      this._anyOutgoingListeners = [];
    return this;
  }
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  notifyOutgoingListeners(e) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const n = this._anyOutgoingListeners.slice();
      for (const r of n)
        r.apply(this, e.data);
    }
  }
}
function ft(t) {
  t = t || {}, this.ms = t.min || 100, this.max = t.max || 1e4, this.factor = t.factor || 2, this.jitter = t.jitter > 0 && t.jitter <= 1 ? t.jitter : 0, this.attempts = 0;
}
ft.prototype.duration = function() {
  var t = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var e = Math.random(), n = Math.floor(e * this.jitter * t);
    t = (Math.floor(e * 10) & 1) == 0 ? t - n : t + n;
  }
  return Math.min(t, this.max) | 0;
};
ft.prototype.reset = function() {
  this.attempts = 0;
};
ft.prototype.setMin = function(t) {
  this.ms = t;
};
ft.prototype.setMax = function(t) {
  this.max = t;
};
ft.prototype.setJitter = function(t) {
  this.jitter = t;
};
class nr extends ee {
  constructor(e, n) {
    var r;
    super(), this.nsps = {}, this.subs = [], e && typeof e == "object" && (n = e, e = void 0), n = n || {}, n.path = n.path || "/socket.io", this.opts = n, fn(this, n), this.reconnection(n.reconnection !== !1), this.reconnectionAttempts(n.reconnectionAttempts || 1 / 0), this.reconnectionDelay(n.reconnectionDelay || 1e3), this.reconnectionDelayMax(n.reconnectionDelayMax || 5e3), this.randomizationFactor((r = n.randomizationFactor) !== null && r !== void 0 ? r : 0.5), this.backoff = new ft({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    }), this.timeout(n.timeout == null ? 2e4 : n.timeout), this._readyState = "closed", this.uri = e;
    const s = n.parser || qc;
    this.encoder = new s.Encoder(), this.decoder = new s.Decoder(), this._autoConnect = n.autoConnect !== !1, this._autoConnect && this.open();
  }
  reconnection(e) {
    return arguments.length ? (this._reconnection = !!e, this) : this._reconnection;
  }
  reconnectionAttempts(e) {
    return e === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = e, this);
  }
  reconnectionDelay(e) {
    var n;
    return e === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = e, (n = this.backoff) === null || n === void 0 || n.setMin(e), this);
  }
  randomizationFactor(e) {
    var n;
    return e === void 0 ? this._randomizationFactor : (this._randomizationFactor = e, (n = this.backoff) === null || n === void 0 || n.setJitter(e), this);
  }
  reconnectionDelayMax(e) {
    var n;
    return e === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = e, (n = this.backoff) === null || n === void 0 || n.setMax(e), this);
  }
  timeout(e) {
    return arguments.length ? (this._timeout = e, this) : this._timeout;
  }
  maybeReconnectOnOpen() {
    !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect();
  }
  open(e) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new Ve(this.uri, this.opts);
    const n = this.engine, r = this;
    this._readyState = "opening", this.skipReconnect = !1;
    const s = _e(n, "open", function() {
      r.onopen(), e && e();
    }), i = (c) => {
      this.cleanup(), this._readyState = "closed", this.emitReserved("error", c), e ? e(c) : this.maybeReconnectOnOpen();
    }, o = _e(n, "error", i);
    if (this._timeout !== !1) {
      const c = this._timeout, l = this.setTimeoutFn(() => {
        s(), i(new Error("timeout")), n.close();
      }, c);
      this.opts.autoUnref && l.unref(), this.subs.push(() => {
        this.clearTimeoutFn(l);
      });
    }
    return this.subs.push(s), this.subs.push(o), this;
  }
  connect(e) {
    return this.open(e);
  }
  onopen() {
    this.cleanup(), this._readyState = "open", this.emitReserved("open");
    const e = this.engine;
    this.subs.push(_e(e, "ping", this.onping.bind(this)), _e(e, "data", this.ondata.bind(this)), _e(e, "error", this.onerror.bind(this)), _e(e, "close", this.onclose.bind(this)), _e(this.decoder, "decoded", this.ondecoded.bind(this)));
  }
  onping() {
    this.emitReserved("ping");
  }
  ondata(e) {
    try {
      this.decoder.add(e);
    } catch (n) {
      this.onclose("parse error", n);
    }
  }
  ondecoded(e) {
    yr(() => {
      this.emitReserved("packet", e);
    }, this.setTimeoutFn);
  }
  onerror(e) {
    this.emitReserved("error", e);
  }
  socket(e, n) {
    let r = this.nsps[e];
    return r ? this._autoConnect && !r.active && r.connect() : (r = new oi(this, e, n), this.nsps[e] = r), r;
  }
  _destroy(e) {
    const n = Object.keys(this.nsps);
    for (const r of n)
      if (this.nsps[r].active)
        return;
    this._close();
  }
  _packet(e) {
    const n = this.encoder.encode(e);
    for (let r = 0; r < n.length; r++)
      this.engine.write(n[r], e.options);
  }
  cleanup() {
    this.subs.forEach((e) => e()), this.subs.length = 0, this.decoder.destroy();
  }
  _close() {
    this.skipReconnect = !0, this._reconnecting = !1, this.onclose("forced close"), this.engine && this.engine.close();
  }
  disconnect() {
    return this._close();
  }
  onclose(e, n) {
    this.cleanup(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", e, n), this._reconnection && !this.skipReconnect && this.reconnect();
  }
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const e = this;
    if (this.backoff.attempts >= this._reconnectionAttempts)
      this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = !1;
    else {
      const n = this.backoff.duration();
      this._reconnecting = !0;
      const r = this.setTimeoutFn(() => {
        e.skipReconnect || (this.emitReserved("reconnect_attempt", e.backoff.attempts), !e.skipReconnect && e.open((s) => {
          s ? (e._reconnecting = !1, e.reconnect(), this.emitReserved("reconnect_error", s)) : e.onreconnect();
        }));
      }, n);
      this.opts.autoUnref && r.unref(), this.subs.push(() => {
        this.clearTimeoutFn(r);
      });
    }
  }
  onreconnect() {
    const e = this.backoff.attempts;
    this._reconnecting = !1, this.backoff.reset(), this.emitReserved("reconnect", e);
  }
}
const gt = {};
function Yt(t, e) {
  typeof t == "object" && (e = t, t = void 0), e = e || {};
  const n = Ac(t, e.path || "/socket.io"), r = n.source, s = n.id, i = n.path, o = gt[s] && i in gt[s].nsps, c = e.forceNew || e["force new connection"] || e.multiplex === !1 || o;
  let l;
  return c ? l = new nr(r, e) : (gt[s] || (gt[s] = new nr(r, e)), l = gt[s]), n.query && !e.query && (e.query = n.queryKey), l.socket(n.path, e);
}
Object.assign(Yt, {
  Manager: nr,
  Socket: oi,
  io: Yt,
  connect: Yt
});
class $c {
  constructor(e, n, r, s) {
    Ie(this, "socket_port");
    Ie(this, "host");
    Ie(this, "port");
    Ie(this, "protocol");
    Ie(this, "url");
    Ie(this, "site_name");
    Ie(this, "socket");
    var i, o, c, l;
    if (this.socket_port = r != null ? r : "9000", this.host = (i = window.location) == null ? void 0 : i.hostname, this.port = (o = window.location) != null && o.port ? `:${this.socket_port}` : "", this.protocol = ((c = window.location) == null ? void 0 : c.protocol) === "https:" ? "https" : "http", e) {
      let a = new URL(e);
      a.port = "", r ? (a.port = r, this.url = a.toString()) : this.url = a.toString();
    } else
      this.url = `${this.protocol}://${this.host}${this.port}/`;
    n && (this.url = `${this.url}${n}`), this.site_name = n, this.socket = Yt(`${this.url}`, {
      withCredentials: !0,
      secure: this.protocol === "https",
      extraHeaders: s && s.useToken === !0 ? {
        Authorization: `${s.type} ${(l = s.token) == null ? void 0 : l.call(s)}`
      } : {}
    });
  }
}
var ai = { exports: {} }, vt = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var as;
function Mc() {
  if (as)
    return vt;
  as = 1;
  var t = Xe, e = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, s = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function o(c, l, a) {
    var f, h = {}, y = null, m = null;
    a !== void 0 && (y = "" + a), l.key !== void 0 && (y = "" + l.key), l.ref !== void 0 && (m = l.ref);
    for (f in l)
      r.call(l, f) && !i.hasOwnProperty(f) && (h[f] = l[f]);
    if (c && c.defaultProps)
      for (f in l = c.defaultProps, l)
        h[f] === void 0 && (h[f] = l[f]);
    return { $$typeof: e, type: c, key: y, ref: m, props: h, _owner: s.current };
  }
  return vt.Fragment = n, vt.jsx = o, vt.jsxs = o, vt;
}
var wt = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var cs;
function Hc() {
  return cs || (cs = 1, process.env.NODE_ENV !== "production" && function() {
    var t = Xe, e = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), s = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), c = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), a = Symbol.for("react.suspense"), f = Symbol.for("react.suspense_list"), h = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), m = Symbol.for("react.offscreen"), p = Symbol.iterator, g = "@@iterator";
    function w(u) {
      if (u === null || typeof u != "object")
        return null;
      var v = p && u[p] || u[g];
      return typeof v == "function" ? v : null;
    }
    var b = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function E(u) {
      {
        for (var v = arguments.length, _ = new Array(v > 1 ? v - 1 : 0), R = 1; R < v; R++)
          _[R - 1] = arguments[R];
        S("error", u, _);
      }
    }
    function S(u, v, _) {
      {
        var R = b.ReactDebugCurrentFrame, N = R.getStackAddendum();
        N !== "" && (v += "%s", _ = _.concat([N]));
        var q = _.map(function(D) {
          return String(D);
        });
        q.unshift("Warning: " + v), Function.prototype.apply.call(console[u], console, q);
      }
    }
    var M = !1, L = !1, k = !1, z = !1, T = !1, W;
    W = Symbol.for("react.module.reference");
    function B(u) {
      return !!(typeof u == "string" || typeof u == "function" || u === r || u === i || T || u === s || u === a || u === f || z || u === m || M || L || k || typeof u == "object" && u !== null && (u.$$typeof === y || u.$$typeof === h || u.$$typeof === o || u.$$typeof === c || u.$$typeof === l || u.$$typeof === W || u.getModuleId !== void 0));
    }
    function ie(u, v, _) {
      var R = u.displayName;
      if (R)
        return R;
      var N = v.displayName || v.name || "";
      return N !== "" ? _ + "(" + N + ")" : _;
    }
    function fe(u) {
      return u.displayName || "Context";
    }
    function V(u) {
      if (u == null)
        return null;
      if (typeof u.tag == "number" && E("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof u == "function")
        return u.displayName || u.name || null;
      if (typeof u == "string")
        return u;
      switch (u) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case s:
          return "StrictMode";
        case a:
          return "Suspense";
        case f:
          return "SuspenseList";
      }
      if (typeof u == "object")
        switch (u.$$typeof) {
          case c:
            var v = u;
            return fe(v) + ".Consumer";
          case o:
            var _ = u;
            return fe(_._context) + ".Provider";
          case l:
            return ie(u, u.render, "ForwardRef");
          case h:
            var R = u.displayName || null;
            return R !== null ? R : V(u.type) || "Memo";
          case y: {
            var N = u, q = N._payload, D = N._init;
            try {
              return V(D(q));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var H = Object.assign, ae = 0, Oe, K, ce, Pe, Qe, we, re;
    function ke() {
    }
    ke.__reactDisabledLog = !0;
    function Me() {
      {
        if (ae === 0) {
          Oe = console.log, K = console.info, ce = console.warn, Pe = console.error, Qe = console.group, we = console.groupCollapsed, re = console.groupEnd;
          var u = {
            configurable: !0,
            enumerable: !0,
            value: ke,
            writable: !0
          };
          Object.defineProperties(console, {
            info: u,
            log: u,
            warn: u,
            error: u,
            group: u,
            groupCollapsed: u,
            groupEnd: u
          });
        }
        ae++;
      }
    }
    function He() {
      {
        if (ae--, ae === 0) {
          var u = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: H({}, u, {
              value: Oe
            }),
            info: H({}, u, {
              value: K
            }),
            warn: H({}, u, {
              value: ce
            }),
            error: H({}, u, {
              value: Pe
            }),
            group: H({}, u, {
              value: Qe
            }),
            groupCollapsed: H({}, u, {
              value: we
            }),
            groupEnd: H({}, u, {
              value: re
            })
          });
        }
        ae < 0 && E("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Ue = b.ReactCurrentDispatcher, Ze;
    function et(u, v, _) {
      {
        if (Ze === void 0)
          try {
            throw Error();
          } catch (N) {
            var R = N.stack.trim().match(/\n( *(at )?)/);
            Ze = R && R[1] || "";
          }
        return `
` + Ze + u;
      }
    }
    var ht = !1, xe;
    {
      var At = typeof WeakMap == "function" ? WeakMap : Map;
      xe = new At();
    }
    function U(u, v) {
      if (!u || ht)
        return "";
      {
        var _ = xe.get(u);
        if (_ !== void 0)
          return _;
      }
      var R;
      ht = !0;
      var N = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var q;
      q = Ue.current, Ue.current = null, Me();
      try {
        if (v) {
          var D = function() {
            throw Error();
          };
          if (Object.defineProperty(D.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(D, []);
            } catch (Fe) {
              R = Fe;
            }
            Reflect.construct(u, [], D);
          } else {
            try {
              D.call();
            } catch (Fe) {
              R = Fe;
            }
            u.call(D.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Fe) {
            R = Fe;
          }
          u();
        }
      } catch (Fe) {
        if (Fe && R && typeof Fe.stack == "string") {
          for (var C = Fe.stack.split(`
`), le = R.stack.split(`
`), J = C.length - 1, Q = le.length - 1; J >= 1 && Q >= 0 && C[J] !== le[Q]; )
            Q--;
          for (; J >= 1 && Q >= 0; J--, Q--)
            if (C[J] !== le[Q]) {
              if (J !== 1 || Q !== 1)
                do
                  if (J--, Q--, Q < 0 || C[J] !== le[Q]) {
                    var me = `
` + C[J].replace(" at new ", " at ");
                    return u.displayName && me.includes("<anonymous>") && (me = me.replace("<anonymous>", u.displayName)), typeof u == "function" && xe.set(u, me), me;
                  }
                while (J >= 1 && Q >= 0);
              break;
            }
        }
      } finally {
        ht = !1, Ue.current = q, He(), Error.prepareStackTrace = N;
      }
      var st = u ? u.displayName || u.name : "", xr = st ? et(st) : "";
      return typeof u == "function" && xe.set(u, xr), xr;
    }
    function j(u, v, _) {
      return U(u, !1);
    }
    function oe(u) {
      var v = u.prototype;
      return !!(v && v.isReactComponent);
    }
    function $(u, v, _) {
      if (u == null)
        return "";
      if (typeof u == "function")
        return U(u, oe(u));
      if (typeof u == "string")
        return et(u);
      switch (u) {
        case a:
          return et("Suspense");
        case f:
          return et("SuspenseList");
      }
      if (typeof u == "object")
        switch (u.$$typeof) {
          case l:
            return j(u.render);
          case h:
            return $(u.type, v, _);
          case y: {
            var R = u, N = R._payload, q = R._init;
            try {
              return $(q(N), v, _);
            } catch {
            }
          }
        }
      return "";
    }
    var ue = Object.prototype.hasOwnProperty, Ne = {}, G = b.ReactDebugCurrentFrame;
    function X(u) {
      if (u) {
        var v = u._owner, _ = $(u.type, u._source, v ? v.type : null);
        G.setExtraStackFrame(_);
      } else
        G.setExtraStackFrame(null);
    }
    function be(u, v, _, R, N) {
      {
        var q = Function.call.bind(ue);
        for (var D in u)
          if (q(u, D)) {
            var C = void 0;
            try {
              if (typeof u[D] != "function") {
                var le = Error((R || "React class") + ": " + _ + " type `" + D + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof u[D] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw le.name = "Invariant Violation", le;
              }
              C = u[D](v, D, R, _, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (J) {
              C = J;
            }
            C && !(C instanceof Error) && (X(N), E("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", R || "React class", _, D, typeof C), X(null)), C instanceof Error && !(C.message in Ne) && (Ne[C.message] = !0, X(N), E("Failed %s type: %s", _, C.message), X(null));
          }
      }
    }
    var Dt = Array.isArray;
    function tt(u) {
      return Dt(u);
    }
    function Lt(u) {
      {
        var v = typeof Symbol == "function" && Symbol.toStringTag, _ = v && u[Symbol.toStringTag] || u.constructor.name || "Object";
        return _;
      }
    }
    function he(u) {
      try {
        return pe(u), !1;
      } catch {
        return !0;
      }
    }
    function pe(u) {
      return "" + u;
    }
    function nt(u) {
      if (he(u))
        return E("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Lt(u)), pe(u);
    }
    var We = b.ReactCurrentOwner, dt = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, wr, br, pn;
    pn = {};
    function ui(u) {
      if (ue.call(u, "ref")) {
        var v = Object.getOwnPropertyDescriptor(u, "ref").get;
        if (v && v.isReactWarning)
          return !1;
      }
      return u.ref !== void 0;
    }
    function li(u) {
      if (ue.call(u, "key")) {
        var v = Object.getOwnPropertyDescriptor(u, "key").get;
        if (v && v.isReactWarning)
          return !1;
      }
      return u.key !== void 0;
    }
    function fi(u, v) {
      if (typeof u.ref == "string" && We.current && v && We.current.stateNode !== v) {
        var _ = V(We.current.type);
        pn[_] || (E('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', V(We.current.type), u.ref), pn[_] = !0);
      }
    }
    function hi(u, v) {
      {
        var _ = function() {
          wr || (wr = !0, E("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", v));
        };
        _.isReactWarning = !0, Object.defineProperty(u, "key", {
          get: _,
          configurable: !0
        });
      }
    }
    function di(u, v) {
      {
        var _ = function() {
          br || (br = !0, E("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", v));
        };
        _.isReactWarning = !0, Object.defineProperty(u, "ref", {
          get: _,
          configurable: !0
        });
      }
    }
    var pi = function(u, v, _, R, N, q, D) {
      var C = {
        $$typeof: e,
        type: u,
        key: v,
        ref: _,
        props: D,
        _owner: q
      };
      return C._store = {}, Object.defineProperty(C._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(C, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: R
      }), Object.defineProperty(C, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: N
      }), Object.freeze && (Object.freeze(C.props), Object.freeze(C)), C;
    };
    function mi(u, v, _, R, N) {
      {
        var q, D = {}, C = null, le = null;
        _ !== void 0 && (nt(_), C = "" + _), li(v) && (nt(v.key), C = "" + v.key), ui(v) && (le = v.ref, fi(v, N));
        for (q in v)
          ue.call(v, q) && !dt.hasOwnProperty(q) && (D[q] = v[q]);
        if (u && u.defaultProps) {
          var J = u.defaultProps;
          for (q in J)
            D[q] === void 0 && (D[q] = J[q]);
        }
        if (C || le) {
          var Q = typeof u == "function" ? u.displayName || u.name || "Unknown" : u;
          C && hi(D, Q), le && di(D, Q);
        }
        return pi(u, C, le, N, R, We.current, D);
      }
    }
    var mn = b.ReactCurrentOwner, _r = b.ReactDebugCurrentFrame;
    function rt(u) {
      if (u) {
        var v = u._owner, _ = $(u.type, u._source, v ? v.type : null);
        _r.setExtraStackFrame(_);
      } else
        _r.setExtraStackFrame(null);
    }
    var yn;
    yn = !1;
    function gn(u) {
      return typeof u == "object" && u !== null && u.$$typeof === e;
    }
    function Er() {
      {
        if (mn.current) {
          var u = V(mn.current.type);
          if (u)
            return `

Check the render method of \`` + u + "`.";
        }
        return "";
      }
    }
    function yi(u) {
      {
        if (u !== void 0) {
          var v = u.fileName.replace(/^.*[\\\/]/, ""), _ = u.lineNumber;
          return `

Check your code at ` + v + ":" + _ + ".";
        }
        return "";
      }
    }
    var Rr = {};
    function gi(u) {
      {
        var v = Er();
        if (!v) {
          var _ = typeof u == "string" ? u : u.displayName || u.name;
          _ && (v = `

Check the top-level render call using <` + _ + ">.");
        }
        return v;
      }
    }
    function Sr(u, v) {
      {
        if (!u._store || u._store.validated || u.key != null)
          return;
        u._store.validated = !0;
        var _ = gi(v);
        if (Rr[_])
          return;
        Rr[_] = !0;
        var R = "";
        u && u._owner && u._owner !== mn.current && (R = " It was passed a child from " + V(u._owner.type) + "."), rt(u), E('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', _, R), rt(null);
      }
    }
    function Tr(u, v) {
      {
        if (typeof u != "object")
          return;
        if (tt(u))
          for (var _ = 0; _ < u.length; _++) {
            var R = u[_];
            gn(R) && Sr(R, v);
          }
        else if (gn(u))
          u._store && (u._store.validated = !0);
        else if (u) {
          var N = w(u);
          if (typeof N == "function" && N !== u.entries)
            for (var q = N.call(u), D; !(D = q.next()).done; )
              gn(D.value) && Sr(D.value, v);
        }
      }
    }
    function vi(u) {
      {
        var v = u.type;
        if (v == null || typeof v == "string")
          return;
        var _;
        if (typeof v == "function")
          _ = v.propTypes;
        else if (typeof v == "object" && (v.$$typeof === l || v.$$typeof === h))
          _ = v.propTypes;
        else
          return;
        if (_) {
          var R = V(v);
          be(_, u.props, "prop", R, u);
        } else if (v.PropTypes !== void 0 && !yn) {
          yn = !0;
          var N = V(v);
          E("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", N || "Unknown");
        }
        typeof v.getDefaultProps == "function" && !v.getDefaultProps.isReactClassApproved && E("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function wi(u) {
      {
        for (var v = Object.keys(u.props), _ = 0; _ < v.length; _++) {
          var R = v[_];
          if (R !== "children" && R !== "key") {
            rt(u), E("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", R), rt(null);
            break;
          }
        }
        u.ref !== null && (rt(u), E("Invalid attribute `ref` supplied to `React.Fragment`."), rt(null));
      }
    }
    function Or(u, v, _, R, N, q) {
      {
        var D = B(u);
        if (!D) {
          var C = "";
          (u === void 0 || typeof u == "object" && u !== null && Object.keys(u).length === 0) && (C += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var le = yi(N);
          le ? C += le : C += Er();
          var J;
          u === null ? J = "null" : tt(u) ? J = "array" : u !== void 0 && u.$$typeof === e ? (J = "<" + (V(u.type) || "Unknown") + " />", C = " Did you accidentally export a JSX literal instead of a component?") : J = typeof u, E("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", J, C);
        }
        var Q = mi(u, v, _, N, q);
        if (Q == null)
          return Q;
        if (D) {
          var me = v.children;
          if (me !== void 0)
            if (R)
              if (tt(me)) {
                for (var st = 0; st < me.length; st++)
                  Tr(me[st], u);
                Object.freeze && Object.freeze(me);
              } else
                E("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Tr(me, u);
        }
        return u === r ? wi(Q) : vi(Q), Q;
      }
    }
    function bi(u, v, _) {
      return Or(u, v, _, !0);
    }
    function _i(u, v, _) {
      return Or(u, v, _, !1);
    }
    var Ei = _i, Ri = bi;
    wt.Fragment = r, wt.jsx = Ei, wt.jsxs = Ri;
  }()), wt;
}
(function(t) {
  process.env.NODE_ENV === "production" ? t.exports = Mc() : t.exports = Hc();
})(ai);
const us = ai.exports.jsx, ne = ls(null), Gc = ({
  url: t = "",
  tokenParams: e,
  socketPort: n,
  swrConfig: r,
  siteName: s,
  enableSocket: i = !0,
  children: o,
  customHeaders: c
}) => {
  const l = Kt(() => {
    const a = new va.FrappeApp(t, e, void 0, c);
    return {
      url: t,
      tokenParams: e,
      app: a,
      auth: a.auth(),
      db: a.db(),
      call: a.call(),
      file: a.file(),
      socket: i ? new $c(t, s, n, e).socket : void 0,
      enableSocket: i,
      socketPort: n
    };
  }, [t, e, n, i, c]);
  return /* @__PURE__ */ us(ne.Provider, {
    value: l,
    children: /* @__PURE__ */ us(Wa, {
      value: r,
      children: o
    })
  });
}, Xc = (t) => {
  const {
    url: e,
    auth: n,
    tokenParams: r
  } = Y(ne), [s, i] = I(), o = P(() => {
    const p = document.cookie.split(";").find((g) => g.trim().startsWith("user_id="));
    if (p) {
      const g = p.split("=")[1];
      i(g && g !== "Guest" ? g : null);
    } else
      i(null);
  }, []);
  at(() => {
    r && r.useToken ? i(null) : o();
  }, []);
  const {
    data: c,
    error: l,
    isLoading: a,
    isValidating: f,
    mutate: h
  } = lt(() => r && r.useToken || s ? `${e}/api/method/frappe.auth.get_logged_user` : null, () => n.getLoggedInUser(), {
    onError: () => {
      i(null);
    },
    shouldRetryOnError: !1,
    revalidateOnFocus: !1,
    ...t
  }), y = P(async (p) => n.loginWithUsernamePassword(p).then((g) => (o(), g)), []), m = P(async () => n.logout().then(() => h(null)).then(() => i(null)), []);
  return {
    isLoading: s === void 0 || a,
    currentUser: c,
    isValidating: f,
    error: l,
    login: y,
    logout: m,
    updateCurrentUser: h,
    getUserCookie: o
  };
}, hn = (t, e, n) => {
  let r = `${e}/api/resource/`;
  return n ? r += `${t}/${n}` : r += `${t}`, r;
}, Qc = (t, e, n, r) => {
  const {
    url: s,
    db: i
  } = Y(ne);
  return lt(n === void 0 ? hn(t, s, e) : n, () => i.getDoc(t, e), r);
}, Zc = (t, e, n, r) => {
  const {
    db: s,
    url: i
  } = Y(ne), o = n === void 0 ? hn(t, i, e) : n;
  return P(() => {
    ln(o, () => s.getDoc(t, e));
  }, [o, t, e]);
}, ci = (t) => {
  var n, r, s;
  let e = "";
  if (t != null && t.fields && (e += "fields=" + JSON.stringify(t == null ? void 0 : t.fields) + "&"), t != null && t.filters && (e += "filters=" + JSON.stringify(t == null ? void 0 : t.filters) + "&"), t != null && t.orFilters && (e += "or_filters=" + JSON.stringify(t == null ? void 0 : t.orFilters) + "&"), t != null && t.limit_start && (e += "limit_start=" + JSON.stringify(t == null ? void 0 : t.limit_start) + "&"), t != null && t.limit && (e += "limit=" + JSON.stringify(t == null ? void 0 : t.limit) + "&"), t != null && t.groupBy && (e += "group_by=" + String(t.groupBy) + "&"), t != null && t.orderBy) {
    const i = `${String((n = t.orderBy) == null ? void 0 : n.field)} ${(s = (r = t.orderBy) == null ? void 0 : r.order) != null ? s : "asc"}`;
    e += "order_by=" + i + "&";
  }
  return t != null && t.asDict && (e += "as_dict=" + t.asDict), e;
}, eu = (t, e, n, r) => {
  const {
    url: s,
    db: i
  } = Y(ne);
  return lt(n === void 0 ? `${hn(t, s)}?${ci(e)}` : n, () => i.getDocList(t, e), r);
}, tu = (t, e, n) => {
  const {
    db: r,
    url: s
  } = Y(ne), i = n === void 0 ? `${hn(t, s)}?${ci(e)}` : n;
  return P(() => {
    ln(i, () => r.getDocList(t, e));
  }, [i, t, e]);
}, nu = () => {
  const {
    db: t
  } = Y(ne), [e, n] = I(!1), [r, s] = I(null), [i, o] = I(!1), c = P(() => {
    n(!1), s(null), o(!1);
  }, []);
  return {
    createDoc: P(async (a, f) => (s(null), o(!1), n(!0), t.createDoc(a, f).then((h) => (n(!1), o(!0), h)).catch((h) => {
      throw n(!1), o(!1), s(h), h;
    })), []),
    loading: e,
    error: r,
    isCompleted: i,
    reset: c
  };
}, ru = () => {
  const {
    db: t
  } = Y(ne), [e, n] = I(!1), [r, s] = I(null), [i, o] = I(!1), c = P(() => {
    n(!1), s(null), o(!1);
  }, []);
  return {
    updateDoc: P(async (a, f, h) => (s(null), o(!1), n(!0), t.updateDoc(a, f, h).then((y) => (n(!1), o(!0), y)).catch((y) => {
      throw n(!1), o(!1), s(y), y;
    })), []),
    loading: e,
    error: r,
    reset: c,
    isCompleted: i
  };
}, su = () => {
  const {
    db: t
  } = Y(ne), [e, n] = I(!1), [r, s] = I(null), [i, o] = I(!1), c = P(() => {
    n(!1), s(null), o(!1);
  }, []);
  return {
    deleteDoc: P(async (a, f) => (s(null), o(!1), n(!0), t.deleteDoc(a, f).then((h) => (n(!1), o(!0), h)).catch((h) => {
      throw n(!1), o(!1), s(h), h;
    })), []),
    loading: e,
    error: r,
    reset: c,
    isCompleted: i
  };
};
function dn(t) {
  const e = [];
  for (let n in t)
    e.push(encodeURIComponent(n) + "=" + encodeURIComponent(t[n]));
  return e.join("&");
}
const iu = (t, e, n = !1, r = !1, s, i) => {
  const {
    url: o,
    db: c
  } = Y(ne);
  return lt(s === void 0 ? (() => {
    const f = dn(n ? {
      doctype: t,
      filters: e != null ? e : [],
      cache: n,
      debug: r
    } : {
      doctype: t,
      filters: e != null ? e : [],
      debug: r
    });
    return `${o}/api/method/frappe.client.get_count?${f}`;
  })() : s, () => c.getCount(t, e, n, r), i);
}, ou = (t, e, n = !1, r = !1, s) => {
  const {
    db: i,
    url: o
  } = Y(ne), c = s === void 0 ? `${o}/api/method/frappe.client.get_count?${dn({
    doctype: t,
    filters: e != null ? e : [],
    cache: n,
    debug: r
  })}` : s;
  return P(() => {
    ln(c, () => i.getCount(t, e, !1, !1));
  }, [c, t, e]);
}, Wc = (t, e, n, r, s = "GET") => {
  const {
    call: i
  } = Y(ne), o = dn(e != null ? e : {}), c = `${t}?${o}`;
  return {
    ...lt(n === void 0 ? c : n, s === "GET" ? () => i.get(t, e) : () => i.post(t, e), r)
  };
}, au = (t, e, n, r = "GET") => {
  const {
    call: s
  } = Y(ne), i = dn(e != null ? e : {}), o = `${t}?${i}`;
  return P(() => {
    ln(n != null ? n : o, r === "GET" ? () => s.get(t, e) : () => s.post(t, e));
  }, [o, t, e, n]);
}, cu = (t) => {
  const {
    call: e
  } = Y(ne), [n, r] = I(null), [s, i] = I(!1), [o, c] = I(null), [l, a] = I(!1), f = P(() => {
    r(null), i(!1), c(null), a(!1);
  }, []);
  return {
    call: P(async (y) => (c(null), a(!1), i(!0), r(null), e.post(t, y).then((m) => (r(m), i(!1), a(!0), m)).catch((m) => {
      throw i(!1), a(!1), c(m), m;
    })), []),
    result: n,
    loading: s,
    error: o,
    reset: f,
    isCompleted: l
  };
}, uu = (t) => {
  const {
    call: e
  } = Y(ne), [n, r] = I(null), [s, i] = I(!1), [o, c] = I(null), [l, a] = I(!1), f = P(() => {
    r(null), i(!1), c(null), a(!1);
  }, []);
  return {
    call: P(async (y) => (c(null), a(!1), i(!0), r(null), e.put(t, y).then((m) => (r(m), i(!1), a(!0), m)).catch((m) => {
      throw i(!1), a(!1), c(m), m;
    })), []),
    result: n,
    loading: s,
    error: o,
    reset: f,
    isCompleted: l
  };
}, lu = (t) => {
  const {
    call: e
  } = Y(ne), [n, r] = I(null), [s, i] = I(!1), [o, c] = I(null), [l, a] = I(!1), f = P(() => {
    r(null), i(!1), c(null), a(!1);
  }, []);
  return {
    call: P(async (y) => (c(null), a(!1), i(!0), r(null), e.delete(t, y).then((m) => (r(m), i(!1), a(!0), m)).catch((m) => {
      throw i(!1), a(!1), c(m), m;
    })), []),
    result: n,
    loading: s,
    error: o,
    reset: f,
    isCompleted: l
  };
}, fu = () => {
  const {
    file: t
  } = Y(ne), [e, n] = I(0), [r, s] = I(!1), [i, o] = I(null), [c, l] = I(!1), a = P(async (h, y, m) => (f(), s(!0), t.uploadFile(h, y, (p, g) => {
    g && n(Math.round(p / g * 100));
  }, m).then((p) => (l(!0), n(100), s(!1), p.data.message)).catch((p) => {
    throw console.error(p), o(p), s(!1), p;
  })), []), f = P(() => {
    n(0), s(!1), o(null), l(!1);
  }, []);
  return {
    upload: a,
    progress: e,
    loading: r,
    isCompleted: c,
    error: i,
    reset: f
  };
}, hu = (t, e, n = [], r = 20, s = 250) => {
  const i = zc(e, s);
  return Wc("frappe.desk.search.search_link", {
    doctype: t,
    page_length: r,
    txt: i,
    filters: JSON.stringify(n != null ? n : [])
  });
}, zc = (t, e) => {
  const [n, r] = I(t);
  return at(() => {
    const s = setTimeout(() => {
      r(t);
    }, e);
    return () => {
      clearTimeout(s);
    };
  }, [t, e]), n;
}, rr = (t, e) => {
  const {
    socket: n
  } = Y(ne);
  at(() => {
    n === void 0 && console.warn("Socket is not enabled. Please enable socket in FrappeProvider.");
    let r = n == null ? void 0 : n.on(t, e);
    return () => {
      r == null || r.off(t);
    };
  }, [t, e]);
}, du = (t, e, n, r = !0) => {
  const {
    socket: s
  } = Y(ne), [i, o] = I([]);
  at(() => (s === void 0 && console.warn("Socket is not enabled. Please enable socket in FrappeProvider."), s == null || s.emit("doc_subscribe", t, e), s == null || s.io.on("reconnect", () => {
    s == null || s.emit("doc_subscribe", t, e);
  }), r && (s == null || s.emit("doc_open", t, e)), () => {
    s == null || s.emit("doc_unsubscribe", t, e), r && (s == null || s.emit("doc_close", t, e));
  }), [t, e, r]), rr("doc_update", n);
  const c = P(() => {
    s == null || s.emit("doc_open", t, e);
  }, [t, e]), l = P(() => {
    s == null || s.emit("doc_close", t, e);
  }, [t, e]), a = P((f) => {
    f.doctype === t && f.docname === e && o(f.users);
  }, [t, e]);
  return rr("doc_viewers", a), {
    viewers: i,
    emitDocOpen: c,
    emitDocClose: l
  };
}, pu = (t, e) => {
  const {
    socket: n
  } = Y(ne);
  at(() => (n === void 0 && console.warn("Socket is not enabled. Please enable socket in FrappeProvider."), n == null || n.emit("doctype_subscribe", t), n == null || n.io.on("reconnect", () => {
    n == null || n.emit("doctype_subscribe", t);
  }), () => {
    n == null || n.emit("doctype_unsubscribe", t);
  }), [t]), rr("list_update", e);
};
export {
  ne as FrappeContext,
  Gc as FrappeProvider,
  ci as getDocListQueryString,
  hn as getRequestURL,
  ln as preload,
  Xc as useFrappeAuth,
  nu as useFrappeCreateDoc,
  lu as useFrappeDeleteCall,
  su as useFrappeDeleteDoc,
  pu as useFrappeDocTypeEventListener,
  du as useFrappeDocumentEventListener,
  rr as useFrappeEventListener,
  fu as useFrappeFileUpload,
  Wc as useFrappeGetCall,
  Qc as useFrappeGetDoc,
  iu as useFrappeGetDocCount,
  eu as useFrappeGetDocList,
  cu as useFrappePostCall,
  au as useFrappePrefetchCall,
  Zc as useFrappePrefetchDoc,
  ou as useFrappePrefetchDocCount,
  tu as useFrappePrefetchDocList,
  uu as useFrappePutCall,
  ru as useFrappeUpdateDoc,
  lt as useSWR,
  Ia as useSWRConfig,
  Kc as useSWRInfinite,
  hu as useSearch
};
